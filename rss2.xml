<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>dev+log</title>
    <link>https://jihyun22.github.io/</link>
    
    <atom:link href="https://jihyun22.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 17 Aug 2021 09:56:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>베이지안 최적화로 하이퍼파라미터 수정하기 (Bayesian Optimization)</title>
      <link>https://jihyun22.github.io/2020/10/07/Bayesian-Optimization/</link>
      <guid>https://jihyun22.github.io/2020/10/07/Bayesian-Optimization/</guid>
      <pubDate>Wed, 07 Oct 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;이번 포스트에서는 Auto ML 방법 중 하이퍼 파라미터 튜닝에 대해 다루며,  Bayesian Optimization(베이지안 최적화) 방법을 소개하겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>이번 포스트에서는 Auto ML 방법 중 하이퍼 파라미터 튜닝에 대해 다루며,  Bayesian Optimization(베이지안 최적화) 방법을 소개하겠습니다.</p><span id="more"></span><ul><li>참고자료 <a href="https://research.sualab.com/introduction/practice/2019/02/19/bayesian-optimization-overview-1.html">링크</a> (본 포스트는 링크의 자료를 상당 부분 인용, 참고하여 작성되었습니다)</li></ul><hr><h1 id="📝-Bayesian-Optimization"><a href="#📝-Bayesian-Optimization" class="headerlink" title="📝 Bayesian Optimization"></a>📝 Bayesian Optimization</h1><p>베이지안 최적화는 Auto ML 분야에서도 Hyperparameter Optimization(하이퍼 파라미터 튜닝)에 대한 내용입니다. </p><h2 id="Auto-ML"><a href="#Auto-ML" class="headerlink" title="Auto ML"></a>Auto ML</h2><p>우선 Auto ML 분야에 대해 알아보겠습니다.</p><p>Auto ML은 ‘머신러닝으로 설계하는 머신러닝’으로, 학습 데이터가 정형 데이터일 때 Auto ML 기술을 적용하면 적은 노력으로 최적의 결과를 도출할 수 있습니다.</p><p>Auto ML은 크게 3가지로 나뉩니다.</p><ol><li><strong>Automated Feature Learning</strong><ul><li>입력 데이터 중 유의미한 피처를 추출하여 입력으로 사용하는 방법입니다.</li><li>최적의 피처 추출 방법을 학습을 통해 찾을 수 있습니다.</li></ul></li><li><strong>Architecture Search</strong><ul><li>학습을 통해 최적의 아키텍처를 설계하는 방법입니다.</li><li>모델의 구조적 측면을 다루며 Darts 등이 이에 해당합니다.</li></ul></li><li><strong>Hyperparameter Optimization</strong><ul><li>학습을 시키기 위해 필요한 하이퍼파라미터를 학습을 통해 추정합니다.</li></ul></li></ol><p>Auto ML 패키지인 <code>PyCaret</code> 을 사용한다면 위 모든 과정을 한꺼번에 진행할 수 있지만, 이번 포스트에서는 <strong>Hyperparameter Optimization</strong> 위주로 다루겠습니다.</p><h2 id="Hyperparameter-Optimization"><a href="#Hyperparameter-Optimization" class="headerlink" title="Hyperparameter Optimization"></a>Hyperparameter Optimization</h2><p>하이퍼 파라미터 튜닝은 학습을 수행하기 위해 사전에 설정해야 하는 파라미터의 최적값을 탐색하는 문제입니다. </p><p>우선 파라미터는 모델 학습 시 필요한 여러 설정값입니다. 이 파라미터의 값에 따라 학습 결과에 큰 영향을 미칠 수 있습니다. 이러한 값들의 최적 조합을 뽑아내는 방법론이 Hyperparameter입니다.</p><p>Auto ML 을 적용하면 학습률(learning rate), 배치 크기(batch size) 등 학습에 영향을 주는 하이퍼파라미터들을 기존 수동적 조정에서 나아가 학습을 통한 최적의 하이퍼 파라미터를 추정할 수 있습니다.</p><p>먼저 기존 파라미터 탐색 방법을 소개하겠습니다.</p><h3 id="Maual-Search"><a href="#Maual-Search" class="headerlink" title="Maual Search"></a><strong>Maual Search</strong></h3><p>Maual Search 는 수동적으로 파라미터 값을 탐색하는 방법입니다. 여러번의 탐색 과정 중 가장 좋은 결과값을 선택하는 방법으로 주관과 직관에 기반합니다.</p><p>이 방법은 실험을 통해 도출된 결과값이 <strong>실제 최적값인지</strong> 의문을 해소하기 어렵습니다.</p><p><img src="https://jihyun22.github.io/img/bo/ms.JPG" alt="Maual Search"></p><p>나아가 한번에 하나의 파라미터를 추정하는 것이 아니라, 일반적으로 한번에 여러 종류의 파라미터를 동시에 탐색하는데 이러한 경우 파라미터 간 <strong>상호 연관 관계를 무시할 수 없기에</strong> 더욱 복잡한 연산을 수행해야 합니다. </p><p>예시로 Learning rate와 L2 정규화 계수는 서로 상관 관계가 있는 파라미터로 Maual Search 방법으로 조정하기가 어렵습니다.</p><p><img src="https://jihyun22.github.io/img/bo/ms.JPG" alt="lr 과 L2 정규화계수 관계"></p><h3 id="Grid-Search"><a href="#Grid-Search" class="headerlink" title="Grid Search"></a><strong>Grid Search</strong></h3><p>Grid Search 는 Maual Search 의 단점을 보완하여 탐색 구간 내 추정하고자 하는 하이퍼파라미터 값 들을 일정한 간격을 두고 선정하여 가장 높은 성능을 발휘했던 하이퍼파라미터 값을 최종 선정하는 방법입니다.</p><p><img src="https://jihyun22.github.io/img/bo/gs.JPG" alt="Grid Search"></p><p>물론 전체 탐색 대상 구간의 설정 방법, 간격의 길이 설정 방법 등 수동적인 요소는 남아있지만, 균등하고 전역적인 탐색이 가능합니다. 그러나 <strong>추정하고자 하는 하이퍼 파라미터 개수를 늘리게 되면 탐색해야 할 구간도 비례하여 증가하므로 탐색 연산 비용이 기하급수적으로 증가하게 됩니다.</strong> </p><h3 id="Random-Search"><a href="#Random-Search" class="headerlink" title="Random Search"></a><strong>Random Search</strong></h3><p>Random Search는 Grid Search와 비슷한 맥락으로 탐색 대상 구간 내 하이퍼 파라미터 값들을 랜덤 샘플링을 통해 선정합니다.</p><p><img src="https://jihyun22.github.io/img/bo/rs.JPG" alt="Random Search"></p><p>즉, 성능 함수의 최댓값이 예측되는 구간에 파라미터 조합을 랜덤으로 샘플링하여 최적 조합을 탐색하는 방법입니다.</p><p>Grid Search에 비해 불필요한 반복 수행 횟수를 줄일 수 있다는 장점이 있습니다.</p><h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a><strong>정리</strong></h3><p>Random Search와 Grid Search는 하이퍼파라미터 값들의 <strong>성능 결과에 대한 이전의 학습 결과가 반영되지 않습니다</strong>.</p><p>Maual Search의 경우 이전의 학습 결과를 바탕으로 수동으로 조합 값들을 조정했지만 Random Search와 Grid Search는 아직도 불필요한 탐색이 반복됩니다.</p><p><strong>이제부터 소개할 Bayesian Optimization방법은 이와 다르게 이전의 학습 결과를 반영하여 최적 조합을 탐색할 수 있습니다.</strong></p><h2 id="Bayesian-Optimization"><a href="#Bayesian-Optimization" class="headerlink" title="Bayesian Optimization"></a>Bayesian Optimization</h2><p>베이지안 최적화 방법은 목적함수 <code>f</code>에 대해 함수값 <code>f</code>(<code>x</code>)를 최대로 만드는 최적해 <code>x</code>를 탐색하는 방법입니다.</p><p>이때 목적함수 <code>f</code>는 표현식을 명시적으로 알지 못하는 black box fuction 이며 하나의 함수값을 계산하는 데 오랜 시간이 소요된다고 가정합니다. 따라서 가능 한 적은 수의 <code>x</code> 후보에 대해서만 함수값을 연산하며 <code>f</code>를 최대로 만드는 최적해 <code>x</code>를 빠르고 효과적으로 탐색하는 것이 목적입니다.</p><p>이 목적함수 <code>f</code>는 모델의 성능 함수 <code>f</code>, <code>x</code>는 하이퍼 파라미터의 조합으로 생각하면 보다 쉽게 이해할 수 있습니다.</p><p>목적함수 <code>f</code>를 추정하기 위해서는 <strong>이전의 학습 결과가 반영된 모델</strong>(Surrogate Model) 과 <strong>다음 입력값 <code>x</code> 후보를 추천</strong>해주는 함수(Acquisition Function) 이 필요합니다.</p><ul><li><strong>Surrogate Model</strong> : 현재까지 조사된 입력값-함숫값 점들( (<code>x1</code>, <code>f(</code>x<code>1)</code>) (<code>x2</code>, <code>f(x2)</code> …), 을 바탕으로 <code>f</code>를 추정하는 확률모델로 <strong>Gaussian Process</strong> 가 주로 사용됩니다.</li><li><strong>Acquisition Function</strong> : <code>f</code>에 대한 Surrogate Model 결과를 바탕으로 다음 최적 입력값 <code>x</code>를 찾기 위해 다음 입력값 후보 <code>x i+1</code>를 탐색하는 함수입니다.</li></ul><p>이를 수도코드로 표현하면 다음과 같습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> … do</span><br><span class="line">      surrogate model 의 확률적 추적 결과 바탕으로</span><br><span class="line">      Acquisition Function를 최대화하는 입력값 후보xi+<span class="number">1</span>설정</span><br><span class="line">      </span><br><span class="line">      f(xi+<span class="number">1</span>) 계산</span><br><span class="line">      surrogate model에 ( xi, f(xi+<span class="number">1</span>) )추가하여 확률적 추적 수행</span><br><span class="line">      </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>먼저 Surrogate Model으로 가장 많이 사용되는 Gaussian Process에 대해 설명하겠습니다.</p><h3 id="Gaussian-Processes-GP"><a href="#Gaussian-Processes-GP" class="headerlink" title="Gaussian Processes (GP)"></a><strong>Gaussian Processes (GP)</strong></h3><p>보통의 확률 보델은 특정 변수에 대한 확률 분포를 표현합니다. 이에 반해 Gaussian Processes 는 함수에 대한 확률 분포를 나타내며 각 요소의 결합 분포가 가우시안 분포를 따른다는 특징이 있습니다.</p><center><big> f(x)∼GP(μ(x),k(x,x′)) </big></center><p>위 식과 같이 평균 함수 μ와 공분산 함수 k를 사용하여 함수들에 대한 확률 분포를 표현합니다. 사진으로 각 함수의 역할을 자세히 살펴보겠습니다.</p><p><img src="https://jihyun22.github.io/img/bo/gp.JPG" alt="Gaussian Processes"></p><p>위 사진은 t=2,3,4… 에 따라 GP의 연산 과정입니다. 초록색 음영은 Acquisition Function으로 다음 입력값 x를 탐색하고, 보라색 음영과 검정색 실선은 Gaussian Processes으로 f를 추정합니다. 검정색 점선은 <strong>실제 f 값인 미지의 목적 함수</strong>입니다.</p><p> t=2에서 Acquisition Function을 통해 다음 입력값 x(🔻으로 표시)를 탐색합니다.</p><p>t=3에서 탐색된 입력값 x의 함수값(🔴)을 계산한 후 다음 입력값 x를 재 탐색합니다. <strong>해당 과정을 반복하여 f의 최대값을 추정할 수 있습니다.</strong></p><p>Gaussian Processes 부분을 자세히 살펴보겠습니다. <u>중앙 검정색 실선은 입력값 x에 대한 평균값 μ(x)</u>이고, <u>검정색 실선을 둘러싼 보라색 음영은 x 위치 별 표준편차 σ(x)</u>입니다.</p><p>σ(x)의 값을 살펴보면, 조사된 점(위 사진의 observation(x))의 값에서 멀어질수록 σ(x)이 크게 나타납니다(t=2에서 보라색 음영이 확장). 즉, <u>추정한 평균값 μ(x)의 <strong>불확실성이 크다</strong>는 뜻입니다.</u></p><p>거듭 연산이 진행될수록 <code>f</code>의 추정 결과가 압축됩니다(t=4 에서 보라색 음영의 축소). 즉, 조사된 점의 개수가 늘어날수록 평균값 μ(x)의 <strong>불확실성이 감소</strong>됩니다. <u>불확실성이 감소될수록 최적 입력값 x를 찾을 가능성이 높아집니다.</u></p><h3 id="Acquisition-Function"><a href="#Acquisition-Function" class="headerlink" title="Acquisition Function"></a><strong>Acquisition Function</strong></h3><p>Acquisition Function은 <code>f</code>에 대해 확률 추정 모델(GP 등)의 결과를 바탕으로 t+1 번째 입력값 후보 <code>x i+1</code> 를 추천하는 함수입니다. </p><p>이때 최적 입력값 <code>x</code>는 현재까지 조사된 점들 중 함수값이 최대인 점 근방에 위치하거나, 표준편차가 최대인 점 근방(불확실한 영역)에 위치할 가능성이 높습니다. 이 두 가지 경우를 각각 <strong>exploitation</strong>, <strong>exploration</strong> 전략이라 합니다. 이러한 경우의 수를 고려하여 <code>x i+1</code>을 탐색해야 합니다.</p><ol><li><p><strong>exploitation</strong></p><ul><li>현재까지 조사된 점들 중 <strong>함수값이 최대인 점</strong> 근방을 다음 차례에 시도합니다.</li><li>함수값이 가장 큰 점 근방에서 실제 최적 입력값 <code>x</code>를 찾을 가능성이 높기 때문입니다.</li></ul></li><li><p><strong>exploration</strong></p><ul><li>현재까지 추정된 목적 함수 상에서 <strong>표준편차가 최대인 점 근방</strong>을 다음 차례에 시도합니다.</li><li>불확실한 영역에 최적 입력값 <code>x</code>이 존재할 가능성이 높기 때문입니다.</li></ul></li></ol><p>Acquisition Function으로 가장 많이 사용되는 함수는 exploitation, exploration 전략 모두를 사용하는 <strong>Expected Improvement</strong> 입니다.</p><h3 id="Expected-Improvement-EI"><a href="#Expected-Improvement-EI" class="headerlink" title="Expected Improvement(EI)"></a><strong>Expected Improvement(EI)</strong></h3><p>Expected Improvement는 현재까지 추정된 <code>f</code>를 바탕으로 어떤 입력값 <code>x</code>에 대해서 </p><ol><li>현재까지 조사된 점들의 <strong>최대 함수값 <code>f(x+)</code> 보다 큰 함수값을 도출할 확률과</strong></li><li><strong>그 함수값과 최대 함수값 <code>f(x+)</code> 간 차이값</strong>을</li></ol><p>고려하여 <code>x</code>의 유용성을 반환합니다. 아래 그래프로 자세히 살펴보겠습니다.</p><p><img src="https://jihyun22.github.io/img/bo/ei.JPG" alt="Expected Improvement"></p><p>위 그래프는 <code>x+</code> 이 계산된 <code>f</code>에 대해 <strong>다음 후보 입력값인 <code>x1</code>, <code>x2</code>,<code>x3</code> 중 가장 유용한 값을 탐색</strong>하는 과정입니다.</p><p>오른쪽의 초록색 음영은 <strong>최대 함수값 <code>f(x+)</code> 보다 큰 함수값을 도출할 확률</strong> <code>PI(x3)</code> 로,  <u>다음 입력값으로 <code>x3</code>을 채택하는 것이 가장 유용하다고 판단됩니다.</u></p><p>따라서 <code>PI(x3)</code>값에 함수값 f(x3)에 대한 평균(검정색 실선에 해당하는 <code>μ(x3)</code>값) 과 <strong>f(x3)-f(x+)을 가중하여</strong> 최종 EI를 계산합니다.</p><p>이 계산 과정을 통해 <strong>f(x+)보다 큰 함수값을 도출할 수 있는 가능성</strong> 뿐 아니라 <strong>실제로 f(x3)값이 f(x+)보다 얼마나 더 큰 값</strong>인지도 반영할 수 있습니다.</p><p>수식으로 살펴보겠습니다.<br>$$<br>\begin{align}<br>EI(x) &amp; = \mathbb{E} [\max (f(x) - f(x^{+}), 0)] \<br>      &amp; =<br>\begin{cases}<br>        (\mu(\boldsymbol{x}) - f(\boldsymbol{x}^{+})-\xi)\Phi(Z) + \sigma(\boldsymbol{x})\phi(Z) &amp; \text{if}\ \sigma(\boldsymbol{x}) &gt; 0 \<br>    0 &amp; \text{if}\ \sigma(\boldsymbol{x}) = 0<br>\end{cases}<br>\end{align}<br>$$</p><p>$$<br>Z =<br>\begin{cases}<br>    \frac{\mu(\boldsymbol{x})-f(\boldsymbol{x}^{+})-\xi}{\sigma(\boldsymbol{x})} &amp; \text{if}\ \sigma(\boldsymbol{x}) &gt; 0 \<br>    0 &amp; \text{if}\ \sigma(\boldsymbol{x}) = 0<br>\end{cases}<br>$$</p><center> <small><em> EI 계산식 </em></small></center><ul><li><p>Φ : 표준정규분포의 누적분포함수(CDF)</p></li><li><p>ϕ : 표준정규분포의 확률분포함수(PDF)</p></li><li><p>ξ : exploration과 exploitation 간의 <u>상대적 강도를 조절해 주는 파라미터</u></p><ul><li><p>클수록 exploration의 강도가 높아짐</p></li><li><p>작을수록 exploitation의 강도가 높아짐</p></li></ul></li></ul><h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a><strong>결론</strong></h3><p>지금까지 살펴본 <strong>Bayesian Optimization</strong> 의 수행 과정을 살펴보겠습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1. 입력값, 목적 함수 및 그 외 설정값들 정의</span><br><span class="line">    - 입력값 x: 학습률</span><br><span class="line">    - 목적 함수 f(x) : 성능 함수 (e.g. 정확도)</span><br><span class="line">    - 입력값 x의 탐색 대상 구간: (a,b).</span><br><span class="line">    - 맨 처음에 조사할 입력값-함숫값 점들의 갯수: n</span><br><span class="line">    - 맨 마지막 차례까지 조사할 입력값-함숫값 점들의 최대 갯수: N</span><br><span class="line">    </span><br><span class="line">2. 설정한 탐색 대상 구간내에서 처음 n개의 입력값들을 랜덤하게 샘플링하여 선택</span><br><span class="line"></span><br><span class="line">3. 선택한 n개의 입력값 x1,x2,..,xn을 각각 학습률 값으로 설정</span><br><span class="line"></span><br><span class="line">4. 딥러닝 모델을 학습한 뒤, 검증 데이터셋을 사용하여 학습이 완료된 모델의 성능 결과 수치를 계산</span><br><span class="line">    - 이들을 각각 함숫값 f(x1),f(x2),...,f(xn)으로 간주</span><br><span class="line">    </span><br><span class="line">5. 입력값-함숫값 점들의 모음에 대하여 Surrogate Model로 확률적 추정 수행</span><br><span class="line"></span><br><span class="line">6. 조사된 입력값-함숫값 점들이 총 N개에 도달할 때까지 반복</span><br><span class="line">    - 기존 입력값-함숫값 점들의 모음에 대한 Surrogate Model의 확률적 추정 결과를 바탕으로, 입력값 구간 (a,b)(a,b) 내에서의 EI의 값을 계산</span><br><span class="line">    - 그 값이 가장 큰 점을 다음 입력값 후보 xt+1로 선정</span><br><span class="line">    - 다음 입력값 후보 xt+1을 학습률 값으로 설정하여 딥러닝 모델을 학습한 뒤, 검증 데이터셋을 사용하여 학습이 완료된 모델의 성능 결과 수치 계산 → f(xt+1)값</span><br><span class="line">    - 새로운 점 (xt+1,f(xt+1))을 기존 입력값-함숫값 점들의 모음에 추가</span><br><span class="line">    - 갱신된 점들의 모음에 대하여 Surrogate Model로 확률적 추정을 다시 수행</span><br><span class="line">    </span><br><span class="line">7. 총 N개의 입력값-함숫값 점들에 대하여 확률적으로 추정된 목적 함수 결과물을 바탕으로, 평균 함수 μ(x)을 최대로 만드는 최적해 x∗를 최종 선택</span><br><span class="line"></span><br><span class="line">8. 해당 x∗ 값을 학습률로 사용하여 딥러닝 모델을 학습하면, 일반화 성능이 극대화된 모델을 얻을 수 있음</span><br></pre></td></tr></table></figure><h1 id="📗-정리"><a href="#📗-정리" class="headerlink" title="📗 정리"></a><strong>📗 정리</strong></h1><p>이상으로 Bayesian Optimization에 대해 살펴보았습니다. 실제 적용에 대해서는 데이콘의 심리성향 예측 대회 데이터를 바탕으로 다루겠습니다. 아래 링크에서 확인할 수 있습니다.</p><ul><li>[데이콘 심리성향 예측 대회] AUTO ML - 베이지안 최적화 (Bayesian Optimization) 적용하기 </li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><strong>Reference</strong></h2><ul><li>Shahriari et al., Taking the human out of the loop: A review of bayesian optimization.<ul><li><a href="https://www.cs.ox.ac.uk/people/nando.defreitas/publications/BayesOptLoop.pdf">Shahriari, Bobak, et al. “Taking the human out of the loop: A review of bayesian optimization.” Proceedings of the IEEE 104.1 (2016): 148-175.</a></li></ul></li><li>Brochu et al., A tutorial on Bayesian optimization of expensive cost functions, with application to active user modeling and hierarchical reinforcement learning.<ul><li><a href="https://arxiv.org/pdf/1012.2599.pdf?bcsi_scan_dd0fad490e5fad80=fwQqmV5CfHDAMm8dFLewPK+h1WGiAAAAkj1aUQ==&bcsi_scan_filename=1012.2599.pdf&utm_content=buffered388&utm_medium=social&utm_source=plus.google.com&utm_campaign=buffer">Brochu, Eric, Vlad M. Cora, and Nando De Freitas. “A tutorial on Bayesian optimization of expensive cost functions, with application to active user modeling and hierarchical reinforcement learning.” arXiv preprint arXiv:1012.2599 (2010).</a></li></ul></li><li>Bengio et al., Practical recommendations for gradient-based training of deep architectures.<ul><li><a href="https://arxiv.org/pdf/1206.5533.pdf">Bengio, Yoshua. “Practical recommendations for gradient-based training of deep architectures.” Neural networks: Tricks of the trade. Springer, Berlin, Heidelberg, 2012. 437-478.</a></li></ul></li><li>Goodfellow et al., Deep learning.<ul><li><a href="https://www.deeplearningbook.org/">Goodfellow, Ian, et al. Deep learning. Vol. 1. Cambridge: MIT press, 2016.</a></li></ul></li><li>Bergstra and Bengio, Random search for hyper-parameter optimization.<ul><li><a href="http://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a.pdf">Bergstra, James, and Yoshua Bengio. “Random search for hyper-parameter optimization.” Journal of Machine Learning Research 13.Feb (2012): 281-305.</a></li></ul></li><li>Fernando Nogueira, bayesian-optimization: A Python implementation of global optimization with gaussian processes.<ul><li><a href="https://github.com/fmfn/BayesianOptimization">https://github.com/fmfn/BayesianOptimization</a></li></ul></li><li>Hunting Optima, Expected Improvement for Bayesian Optimization: A Derivation.<ul><li><a href="http://ash-aldujaili.github.io/blog/2018/02/01/ei/">http://ash-aldujaili.github.io/blog/2018/02/01/ei/</a></li></ul></li></ul><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning</category>
      
      
      <category domain="https://jihyun22.github.io/tags/Bayesian-Optimization/">Bayesian-Optimization</category>
      
      <category domain="https://jihyun22.github.io/tags/Hyperparameter/">Hyperparameter</category>
      
      
      <comments>https://jihyun22.github.io/2020/10/07/Bayesian-Optimization/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] Goat Latin</title>
      <link>https://jihyun22.github.io/2020/08/19/leetcode-08-19/</link>
      <guid>https://jihyun22.github.io/2020/08/19/leetcode-08-19/</guid>
      <pubDate>Wed, 19 Aug 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;LeetCoding Challenge의 8월 19일 &lt;strong&gt;‘Goat Latin’&lt;/strong&gt; 문제 풀이입니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;August LeetCoding Challenge &lt;a href=&quot;https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/&quot;&gt;&lt;em&gt;week-3-august-15th-august-21st&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>LeetCoding Challenge의 8월 19일 <strong>‘Goat Latin’</strong> 문제 풀이입니다. </p><ul><li>August LeetCoding Challenge <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/"><em>week-3-august-15th-august-21st</em></a></li></ul><span id="more"></span><h2 id="🎯-문제"><a href="#🎯-문제" class="headerlink" title="🎯 문제"></a><strong>🎯 문제</strong></h2><blockquote><ol><li><p>A sentence <code>S</code> is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.</p><p>We would like to convert the sentence to “<em>Goat Latin”</em> (a made-up language similar to Pig Latin.)</p><p>The rules of Goat Latin are as follows:</p><ul><li>If a word begins with a vowel (a, e, i, o, or u), append <code>&quot;ma&quot;</code> to the end of the word.<br>For example, the word ‘apple’ becomes ‘applema’.</li><li>If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add <code>&quot;ma&quot;</code>.<br>For example, the word <code>&quot;goat&quot;</code> becomes <code>&quot;oatgma&quot;</code>.</li><li>Add one letter <code>&#39;a&#39;</code> to the end of each word per its word index in the sentence, starting with 1.<br>For example, the first word gets <code>&quot;a&quot;</code> added to the end, the second word gets <code>&quot;aa&quot;</code> added to the end and so on.</li></ul><p>Return the final sentence representing the conversion from <code>S</code> to Goat Latin. </p></li></ol></blockquote><p>문장을 입력받아 “ “공백을 기준으로 한 단어 단위로 나눕니다. 각 단어의 앞글자가 모음인 경우, “ma”를 붙이며, 자음인 경우 앞글자를 제거한 뒤 “ma”를 붙입니다. 또한 문장의 단어 순서대로 차례대로 누적하여 “a”를 붙이고, 최종 결과를 문장으로 반환합니다.</p><h3 id="Test-Case1"><a href="#Test-Case1" class="headerlink" title="Test Case1"></a><strong>Test Case1</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">&quot;I speak Goat Latin&quot;</span></span><br><span class="line">Output: <span class="string">&quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot;</span></span><br></pre></td></tr></table></figure><h3 id="Test-Case2"><a href="#Test-Case2" class="headerlink" title="Test Case2"></a><strong>Test Case2</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">&quot;The quick brown fox jumped over the lazy dog&quot;</span></span><br><span class="line">Output: <span class="string">&quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot;</span></span><br></pre></td></tr></table></figure><h2 id="🔍-풀이"><a href="#🔍-풀이" class="headerlink" title="🔍 풀이"></a><strong>🔍 풀이</strong></h2><h3 id="해설"><a href="#해설" class="headerlink" title="해설"></a><strong>해설</strong></h3><p>문제의 난이도가 낮아 자세한 설명은 아래의 코드 및 주석으로 대체하겠습니다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a><strong>코드</strong></h3><p>사용 언어는 <code>python3</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># [LeetCode] week-3-august-18th</span></span><br><span class="line"><span class="comment"># Goat Latin</span></span><br><span class="line"><span class="comment"># @Jihyun22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 문장을 입력받아 공백을 기준으로 list에 저장</span></span><br><span class="line">S = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(S)):</span><br><span class="line">    <span class="comment"># 맨 앞 문자가 자음이면</span></span><br><span class="line">    <span class="keyword">if</span> S[i][<span class="number">0</span>].lower() <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]:</span><br><span class="line">        <span class="comment"># 앞 문자를 뒤로 add</span></span><br><span class="line">        S[i] = S[i][<span class="number">1</span>:] + S[i][<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># &quot;ma&quot; add</span></span><br><span class="line">    <span class="comment"># &#x27;a&#x27;를 공백 수+1 만큼 add</span></span><br><span class="line">    S[i] += <span class="string">&quot;ma&quot;</span> + <span class="string">&quot;a&quot;</span>*(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27; &#x27;</span>.join(S).strip(<span class="string">&quot; &quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="📝-Submit"><a href="#📝-Submit" class="headerlink" title="📝 Submit"></a><strong>📝 Submit</strong></h2><p>LeetCode 제출 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        S = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, S.split(<span class="string">&#x27; &#x27;</span>)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(S)):</span><br><span class="line">            <span class="keyword">if</span> S[i][<span class="number">0</span>].lower() <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]:</span><br><span class="line">                S[i] = S[i][<span class="number">1</span>:] + S[i][<span class="number">0</span>]</span><br><span class="line">            S[i] += <span class="string">&quot;ma&quot;</span>+<span class="string">&quot;a&quot;</span>*(i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(S).strip(<span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure><p><em>LeetCode는 사용 언어 별 default 형식으로 작성해야 평가가 진행됩니다.</em> </p><h3 id="채점-결과"><a href="#채점-결과" class="headerlink" title="채점 결과"></a><strong>채점 결과</strong></h3><p><img src="https://jihyun22.github.io/img/leetcode/0819.JPG" alt="leetcode-08-18-Runtime"></p><p>채점 결과, run time은 중-하위 수준이였습니다. 상위 코드를 살펴보니 조금 단순하게 접근한 것이 특징이었습니다. 해당 코드를 첨부하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toGoatLatin</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">         </span><br><span class="line">        W = S.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        out = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(W):</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> s[<span class="number">0</span>].lower()  <span class="keyword">in</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>]:</span><br><span class="line">                s = s + <span class="string">&quot;ma&quot;</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = s[<span class="number">1</span>:] + s[<span class="number">0</span>]</span><br><span class="line">                s = s + <span class="string">&quot;ma&quot;</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span>):</span><br><span class="line">                s = s + <span class="string">&#x27;a&#x27;</span></span><br><span class="line">                i = i-<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            out = out + s + <span class="string">&quot; &quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="built_in">print</span>(W)   </span><br><span class="line">        <span class="keyword">return</span> out[<span class="number">0</span>:<span class="built_in">len</span>(out)-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/leetcode/0819_2.JPG" alt="leetcode-08-18-Memory"></p><p>메모리 측면에서는 효율이 높은 편입니다.</p><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Algorithm/">Algorithm 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/categories/Algorithm/leetcode/">Leetcode 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/leetcode/">leetcode</category>
      
      
      <category domain="https://jihyun22.github.io/tags/leetcode/">leetcode</category>
      
      <category domain="https://jihyun22.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://jihyun22.github.io/tags/python/">python</category>
      
      
      <comments>https://jihyun22.github.io/2020/08/19/leetcode-08-19/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] Numbers With Same Consecutive Differences</title>
      <link>https://jihyun22.github.io/2020/08/18/leetcode-08-18/</link>
      <guid>https://jihyun22.github.io/2020/08/18/leetcode-08-18/</guid>
      <pubDate>Tue, 18 Aug 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;LeetCoding Challenge의 8월 18일 &lt;strong&gt;‘Numbers With Same Consecutive Differences’&lt;/strong&gt; 문제 풀이입니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;August LeetCoding Challenge &lt;a href=&quot;https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/&quot;&gt;&lt;em&gt;week-3-august-15th-august-21st&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>LeetCoding Challenge의 8월 18일 <strong>‘Numbers With Same Consecutive Differences’</strong> 문제 풀이입니다. </p><ul><li>August LeetCoding Challenge <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/"><em>week-3-august-15th-august-21st</em></a></li></ul><span id="more"></span><h2 id="🎯-문제"><a href="#🎯-문제" class="headerlink" title="🎯 문제"></a><strong>🎯 문제</strong></h2><blockquote><p>Return all <strong>non-negative</strong> integers of length <code>N</code> such that the absolute difference between every two consecutive digits is <code>K</code>.</p><p>Note that <strong>every</strong> number in the answer <strong>must not</strong> have leading zeros <strong>except</strong> for the number <code>0</code> itself. For example, <code>01</code> has one leading zero and is invalid, but <code>0</code> is valid.</p><p>You may return the answer in any order.</p><p><strong>Note:</strong></p><ol><li><code>1 &lt;= N &lt;= 9</code></li><li><code>0 &lt;= K &lt;= 9</code></li></ol></blockquote><p>N은 자릿수, K는 연속된 두 자리 수 사이의 절대 차이로 N과 K를 만족하는 양의 정수(0을 포함하는 자연수)를 반환하는 문제입니다. 이때 반환 순서는 고려할 필요 없으며, 맨 첫자리에 0이 오는 경우는 제외합니다 (01은 유효하지 않음, 0은 유효함).</p><h3 id="Test-Case1"><a href="#Test-Case1" class="headerlink" title="Test Case1"></a><strong>Test Case1</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = <span class="number">3</span>, K = <span class="number">7</span></span><br><span class="line">Output: [<span class="number">181</span>,<span class="number">292</span>,<span class="number">707</span>,<span class="number">818</span>,<span class="number">929</span>]</span><br></pre></td></tr></table></figure><h3 id="Test-Case2"><a href="#Test-Case2" class="headerlink" title="Test Case2"></a><strong>Test Case2</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: N = <span class="number">2</span>, K = <span class="number">1</span></span><br><span class="line">Output: [<span class="number">10</span>,<span class="number">12</span>,<span class="number">21</span>,<span class="number">23</span>,<span class="number">32</span>,<span class="number">34</span>,<span class="number">43</span>,<span class="number">45</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">65</span>,<span class="number">67</span>,<span class="number">76</span>,<span class="number">78</span>,<span class="number">87</span>,<span class="number">89</span>,<span class="number">98</span>]</span><br></pre></td></tr></table></figure><h2 id="🔍-풀이"><a href="#🔍-풀이" class="headerlink" title="🔍 풀이"></a>🔍 풀이</h2><h3 id="해설"><a href="#해설" class="headerlink" title="해설"></a><strong>해설</strong></h3><p>이 문제의 edge event는 N=1인 경우의 수 입니다. 이때 결과값은 <code>range(10)</code> 으로 0이 포함됩니다. 따라서 사전에 edge event를 처리해 주는 것이 문제 풀이의 해법이 될 수 있습니다. </p><p>자리수 N을 고려하여 숫자를 조합하는 것도 까다롭습니다. 이때 a*10 + b 꼴에서 a에 10의 자리의 수가 들어가면 100의 자리의 수가 된다는 점을 고려한다면 보다 쉽게 접근할 수 있습니다.</p><p>또한 첫째 자리 수(a*10 + b 에서 a)가 0이 되면 제외된다는 조건은 <code>if a</code> 로 쉽게 처리할 수 있습니다.</p><h4 id="자리수-N-연산"><a href="#자리수-N-연산" class="headerlink" title="자리수 N 연산"></a><strong>자리수 N 연산</strong></h4><p>첫번째 테스트 케이스(N=3, K=7)를 예시로 설명하겠습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">result = &#123;a * 10 + b</span><br><span class="line">          for a in result</span><br><span class="line">          for b in [a % 10 + K, a % 10 - K]</span><br><span class="line">          if a and 0 &lt;= b &lt; 10&#125;</span><br></pre></td></tr></table></figure><p>result의 값은 다음의 표와 같이 계산됩니다.</p><table><thead><tr><th align="center">0 to N-1</th><th align="center">a</th><th align="center">b</th><th align="center">result</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">8</td><td align="center">18, 2, 3, 4, 5, 6, 7, 8, 9</td></tr><tr><td align="center">0</td><td align="center">2</td><td align="center">9</td><td align="center">18, 29, 3, 4, 5, 6, 7, 8, 9</td></tr><tr><td align="center">0</td><td align="center">7</td><td align="center">0</td><td align="center">18, 29, 70, 8, 9</td></tr><tr><td align="center">0</td><td align="center">8</td><td align="center">1</td><td align="center">18, 29, 70, 81, 9</td></tr><tr><td align="center">0</td><td align="center">9</td><td align="center">2</td><td align="center">18, 29, 70, 81, 92</td></tr><tr><td align="center">1</td><td align="center">18</td><td align="center">1</td><td align="center">181, 29, 70, 81, 92</td></tr><tr><td align="center">1</td><td align="center">29</td><td align="center">2</td><td align="center">292, 181,70, 81, 92</td></tr><tr><td align="center">1</td><td align="center">70</td><td align="center">7</td><td align="center">707, 292, 181, 81, 92</td></tr><tr><td align="center">1</td><td align="center">81</td><td align="center">8</td><td align="center">818, 707, 292, 181, 92</td></tr><tr><td align="center">1</td><td align="center">92</td><td align="center">9</td><td align="center">929, 818, 707, 292, 181</td></tr></tbody></table><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a><strong>코드</strong></h3><p>사용 언어는 <code>python3</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># [LeetCode] week-3-august-18th</span></span><br><span class="line"><span class="comment"># Numbers With Same Consecutive Differences</span></span><br><span class="line"><span class="comment"># @Jihyun22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># N과 K가 공백 기준으로 입력되는 경우</span></span><br><span class="line">N, K = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sol</span>(<span class="params">N, K</span>):</span></span><br><span class="line">    <span class="comment"># 0부터 9까지의 result에 저장</span></span><br><span class="line">    result = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 자리수 만큼 반복</span></span><br><span class="line">    <span class="comment"># N=1이면 result = range(10) 반환(edge event)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N - <span class="number">1</span>):</span><br><span class="line">        result = &#123;  <span class="comment"># 자리수 고려</span></span><br><span class="line">                    a * <span class="number">10</span> + b</span><br><span class="line">                    <span class="comment"># result에 저장된 수 만큼 a연산 반복</span></span><br><span class="line">                    <span class="keyword">for</span> a <span class="keyword">in</span> result</span><br><span class="line">                    <span class="comment"># a, b의 절대 차는 K</span></span><br><span class="line">                    <span class="keyword">for</span> b <span class="keyword">in</span> [a % <span class="number">10</span> + K, a % <span class="number">10</span> - K]</span><br><span class="line">                    <span class="comment"># a에는 0이 올 수 없으며, b는 0~9 까지의 자연수</span></span><br><span class="line">                    <span class="keyword">if</span> a <span class="keyword">and</span> <span class="number">0</span> &lt;= b &lt; <span class="number">10</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sol(N, K))</span><br></pre></td></tr></table></figure><h2 id="📝-Submit"><a href="#📝-Submit" class="headerlink" title="📝 Submit"></a><strong>📝 Submit</strong></h2><p>LeetCode 제출 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numsSameConsecDiff</span>(<span class="params">self, N: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = <span class="built_in">range</span>(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N - <span class="number">1</span>):</span><br><span class="line">            result = &#123;a * <span class="number">10</span> + b</span><br><span class="line">                      <span class="keyword">for</span> a <span class="keyword">in</span> result</span><br><span class="line">                      <span class="keyword">for</span> b <span class="keyword">in</span> [a % <span class="number">10</span> + K, a % <span class="number">10</span> - K]</span><br><span class="line">                      <span class="keyword">if</span> a <span class="keyword">and</span> <span class="number">0</span> &lt;= b &lt; <span class="number">10</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(result)</span><br></pre></td></tr></table></figure><p><em>LeetCode는 사용 언어 별 default 형식으로 작성해야 평가가 진행됩니다.</em> </p><h3 id="채점-결과"><a href="#채점-결과" class="headerlink" title="채점 결과"></a><strong>채점 결과</strong></h3><p><img src="https://jihyun22.github.io/img/leetcode/0818.JPG" alt="leetcode-08-18-Runtime"></p><p>채점 결과, run time은 상위 0.5%정도로 좋은 성과를 얻을 수 있었습니다.</p><p><img src="https://jihyun22.github.io/img/leetcode/0818_2.JPG" alt="leetcode-08-17-Memory"></p><p>다만 메모리 측면에서는 아쉬움이 남습니다.  재귀법을 사용한 코드가 메모리 효율이 가장 높았습니다. 해당 코드의 일부를 첨부합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>)) </span><br><span class="line">output = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addRecursive</span>(<span class="params">digits, N, K, output</span>):</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(digits) == N:</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">            x = <span class="number">10</span> * x + d</span><br><span class="line">        output.append(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y = digits[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> y &gt;= K:</span><br><span class="line">            addRecursive(digits + [y-K], N, K, output)</span><br><span class="line">        <span class="keyword">if</span> K &gt; <span class="number">0</span> <span class="keyword">and</span> y+K &lt;= <span class="number">9</span>:</span><br><span class="line">            addRecursive(digits + [y+K], N, K, output)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        addRecursive([k], N, K, output)</span><br><span class="line">    <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>추가로 덧붙이면, 이 문제는 보편적인 dfs 문제 유형입니다. 기회가 된다면 dfs로 풀이하는 것도 큰 도움이 될 것 같습니다. dfs 풀이 코드도 첨부하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numsSameConsecDiff</span>(<span class="params">self, N: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">1</span>:</span><br><span class="line">            ans.append(<span class="number">0</span>)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">n,num</span>):</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                ans.append(num)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            t = num%<span class="number">10</span></span><br><span class="line">            digits = &#123;t+k&#125;</span><br><span class="line">            digits.add(t-k)</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">                <span class="keyword">if</span> -<span class="number">1</span> &lt; d &lt; <span class="number">10</span>:</span><br><span class="line">                    dfs(n-<span class="number">1</span>,(num*<span class="number">10</span>)+d)</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">            dfs(N-<span class="number">1</span>,x)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Algorithm/">Algorithm 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/categories/Algorithm/leetcode/">Leetcode 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/leetcode/">leetcode</category>
      
      
      <category domain="https://jihyun22.github.io/tags/leetcode/">leetcode</category>
      
      <category domain="https://jihyun22.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://jihyun22.github.io/tags/python/">python</category>
      
      
      <comments>https://jihyun22.github.io/2020/08/18/leetcode-08-18/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] Distribute Candies to People</title>
      <link>https://jihyun22.github.io/2020/08/17/leetcode-08-17/</link>
      <guid>https://jihyun22.github.io/2020/08/17/leetcode-08-17/</guid>
      <pubDate>Mon, 17 Aug 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;LeetCoding Challenge의 8월 17일 &lt;strong&gt;‘Distribute Candies to People’&lt;/strong&gt; 문제 풀이입니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;August LeetCoding Challenge &lt;a href=&quot;https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/&quot;&gt;&lt;em&gt;week-3-august-15th-august-21st&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>LeetCoding Challenge의 8월 17일 <strong>‘Distribute Candies to People’</strong> 문제 풀이입니다. </p><ul><li>August LeetCoding Challenge <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/"><em>week-3-august-15th-august-21st</em></a></li></ul><span id="more"></span><h2 id="🎯-문제"><a href="#🎯-문제" class="headerlink" title="🎯 문제"></a><strong>🎯 문제</strong></h2><blockquote><p>We distribute some number of <code>candies</code>, to a row of <strong><code>n = num_people</code></strong> people in the following way:</p><p>We then give 1 candy to the first person, 2 candies to the second person, and so on until we give <code>n</code> candies to the last person.</p><p>Then, we go back to the start of the row, giving <code>n + 1</code> candies to the first person, <code>n + 2</code> candies to the second person, and so on until we give <code>2 * n</code> candies to the last person.</p><p>This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).</p><p>Return an array (of length <code>num_people</code> and sum <code>candies</code>) that represents the final distribution of candies.</p><p><strong>Constraints:</strong></p><ul><li>1 &lt;= candies &lt;= 10^9</li><li>1 &lt;= num_people &lt;= 1000</li></ul></blockquote><p>캔디의 개수와 사람의 수가 주어지고, 사람에게 캔디를 분배하는 문제입니다. 사람에게 캔디를 1, 2, 3 …개 순서로 분배하며, 마지막 사람까지 나눠준 다음 사탕이 남으면 다시 줄의 시작으로 돌아가 n+1, n+2 … 순으로 재 분배합니다. 사탕이 다 떨어질 때 까지 이런 과정이 반복되며, 마지막 사람은 남은 사탕을 받습니다. 이때, 기존 사탕 분배 개수보다 반드시 한개 더 많이 받을 필요는 없습니다. 결과값은 사탕의 최종 분포를 리스트로 반환합니다.</p><h3 id="Test-Case1"><a href="#Test-Case1" class="headerlink" title="Test Case1"></a><strong>Test Case1</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = <span class="number">7</span>, num_people = <span class="number">4</span></span><br><span class="line">Output: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="Test-Case2"><a href="#Test-Case2" class="headerlink" title="Test Case2"></a><strong>Test Case2</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: candies = <span class="number">10</span>, num_people = <span class="number">3</span></span><br><span class="line">Output: [<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="🔍-풀이"><a href="#🔍-풀이" class="headerlink" title="🔍 풀이"></a><strong>🔍 풀이</strong></h2><h3 id="해설"><a href="#해설" class="headerlink" title="해설"></a>해설</h3><p>1, 2, 3, 4 … 배열의 누적 합 배열 1, 3, 6, 10 … 을 고려하면 쉽게 접근할 수 있습니다.</p><p>사람의 수 만큼의 열을 가진 2차원 배열을 선언한 후, 사탕을 순서대로 분배하여 각 요소의 합을 연산해 결과값을 도출합니다.</p><table><thead><tr><th align="center">Test case 2</th><th align="center">j=0</th><th align="center">j=1</th><th align="center">j=2</th></tr></thead><tbody><tr><td align="center"><strong>i=0</strong></td><td align="center">1 (1)</td><td align="center">2 (3)</td><td align="center">3 (6)</td></tr><tr><td align="center"><strong>i=1</strong></td><td align="center">4 (10)</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>result</strong></td><td align="center"><strong>5</strong></td><td align="center"><strong>2</strong></td><td align="center"><strong>3</strong></td></tr></tbody></table><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a><strong>코드</strong></h3><p>사용 언어는 <code>python3</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># [LeetCode] week-3-august-17th</span></span><br><span class="line"><span class="comment"># Distribute Candies to People</span></span><br><span class="line"><span class="comment"># @Jihyun22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 사탕 수와 사람 수가 각각 공백을 기준으로 입력되는 경우</span></span><br><span class="line">c, p = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">result = [<span class="number">0</span>] * p</span><br><span class="line"></span><br><span class="line"><span class="comment"># candy_sum이 처음으로 10**9 이상일 때 i는 45</span></span><br><span class="line">candy = <span class="number">1</span></span><br><span class="line">candy_sum = <span class="number">0</span></span><br><span class="line">tmp = [[<span class="number">0</span>] * p <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">45</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">45</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(p):</span><br><span class="line">        <span class="keyword">if</span> candy_sum + candy &gt; c:</span><br><span class="line">            tmp[i][j] = c - candy_sum</span><br><span class="line">            candy = -<span class="number">1</span></span><br><span class="line">            result[j] += tmp[i][j]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        tmp[i][j] = candy</span><br><span class="line">        candy_sum += candy</span><br><span class="line">        candy += <span class="number">1</span></span><br><span class="line">        result[j] += tmp[i][j]</span><br><span class="line">    <span class="comment"># 이중 for 문 종료</span></span><br><span class="line">    <span class="keyword">if</span> candy &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><h2 id="📝-Submit"><a href="#📝-Submit" class="headerlink" title="📝 Submit"></a><strong>📝 Submit</strong></h2><p>LeetCode 제출 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distributeCandies</span>(<span class="params">self, candies: <span class="built_in">int</span>, num_people: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = [<span class="number">0</span>] * num_people</span><br><span class="line">        candy = <span class="number">1</span></span><br><span class="line">        candy_sum = <span class="number">0</span></span><br><span class="line">        tmp = [[<span class="number">0</span>] * num_people <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">45</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">45</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(num_people):</span><br><span class="line">                <span class="keyword">if</span> candy_sum + candy &gt; candies:</span><br><span class="line">                    tmp[i][j] = candies - candy_sum</span><br><span class="line">                    candy = -<span class="number">1</span></span><br><span class="line">                    result[j] += tmp[i][j]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                tmp[i][j] = candy</span><br><span class="line">                candy_sum += candy</span><br><span class="line">                candy += <span class="number">1</span></span><br><span class="line">                result[j] += tmp[i][j]</span><br><span class="line">            <span class="keyword">if</span> candy &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><em>LeetCode는 사용 언어 별 default 형식으로 작성해야 평가가 진행됩니다.</em> </p><h3 id="채점-결과"><a href="#채점-결과" class="headerlink" title="채점 결과"></a><strong>채점 결과</strong></h3><p><img src="https://jihyun22.github.io/img/leetcode/0817.JPG" alt="leetcode-08-18-Runtime"></p><p>채점 결과, 가장 보편적인 방법으로 접근한 것으로 판단됩니다. 상위 코드를 통해 run time을 줄일 수 있는 방법을 고민해봐야겠습니다.  아래에 run time = 20ms인 상위 코드 중 일부를 첨부합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">lo, hi = <span class="number">0</span>, candies</span><br><span class="line">        K = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">            k = (lo + hi)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> k*(num_people*(num_people+<span class="number">1</span>))//<span class="number">2</span> + (k*(k-<span class="number">1</span>))//<span class="number">2</span> * num_people**<span class="number">2</span> &lt;= candies:</span><br><span class="line">                K = k</span><br><span class="line">                lo = k + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = k - <span class="number">1</span></span><br><span class="line">        result = [(i+<span class="number">1</span>)*K+num_people*(K*(K-<span class="number">1</span>))//<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_people)]</span><br><span class="line">        candies -= <span class="built_in">sum</span>(result)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_people):</span><br><span class="line">            add = <span class="built_in">min</span>(candies, K * num_people + i + <span class="number">1</span>)</span><br><span class="line">            result[i] += add</span><br><span class="line">            candies -= add</span><br><span class="line">            <span class="keyword">if</span> candies == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> result  </span><br></pre></td></tr></table></figure><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Algorithm/">Algorithm 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/categories/Algorithm/leetcode/">Leetcode 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/leetcode/">leetcode</category>
      
      
      <category domain="https://jihyun22.github.io/tags/leetcode/">leetcode</category>
      
      <category domain="https://jihyun22.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://jihyun22.github.io/tags/python/">python</category>
      
      
      <comments>https://jihyun22.github.io/2020/08/17/leetcode-08-17/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[LeetCode] Best Time to Buy and Sell Stock III</title>
      <link>https://jihyun22.github.io/2020/08/16/leetcode-08-16/</link>
      <guid>https://jihyun22.github.io/2020/08/16/leetcode-08-16/</guid>
      <pubDate>Sun, 16 Aug 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;LeetCoding Challenge의 8월 16일 &lt;strong&gt;‘Best Time to Buy and Sell Stock III’&lt;/strong&gt; 문제 풀이입니다. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;August LeetCoding Challenge &lt;a href=&quot;https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/&quot;&gt;&lt;em&gt;week-3-august-15th-august-21st&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>LeetCoding Challenge의 8월 16일 <strong>‘Best Time to Buy and Sell Stock III’</strong> 문제 풀이입니다. </p><ul><li>August LeetCoding Challenge <a href="https://leetcode.com/explore/challenge/card/august-leetcoding-challenge/551/week-3-august-15th-august-21st/"><em>week-3-august-15th-august-21st</em></a></li></ul><span id="more"></span><h2 id="🎯-문제"><a href="#🎯-문제" class="headerlink" title="🎯 문제"></a><strong>🎯 문제</strong></h2><blockquote><p>Say you have an array for which the <em>i</em>th element is the price of a given stock on day <em>i</em>.</p><p>Design an algorithm to find the maximum profit. You may complete at most <em>two</em> transactions.</p><p><strong>Note:</strong> You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p></blockquote><p>주식의 가격이 날짜별로 주어지면 주식을 사고 팔아서(transaction) 얻을 수 있는 최대 이익을 찾아내는 문제입니다. transaction은 중복으로 이루어질 수 없으며, 최대 2번입니다.</p><h3 id="Test-Case1"><a href="#Test-Case1" class="headerlink" title="Test Case1"></a><strong>Test Case1</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">Output: <span class="number">6</span></span><br><span class="line">Explanation: <span class="number">4</span>일날 주식을 구입하여 <span class="number">6</span>일날 팔고(이익(<span class="number">3</span>-<span class="number">0</span>) = <span class="number">3</span>), <span class="number">7</span>일날 구입하여 <span class="number">8</span>일날 팔아서(이익(<span class="number">4</span>-<span class="number">1</span>)=<span class="number">3</span>) 최대 이익은 <span class="number">6</span> 입니다. </span><br><span class="line">Note : transaction은 최대 <span class="number">2</span>번 이루어진다는 점에 유의해야 합니다.</span><br></pre></td></tr></table></figure><h3 id="Test-Case2"><a href="#Test-Case2" class="headerlink" title="Test Case2"></a><strong>Test Case2</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">Output: <span class="number">4</span></span><br><span class="line">Explanation: <span class="number">1</span>일날 주식을 구입하여 <span class="number">5</span>일날 팔아서(이익(<span class="number">5</span>-<span class="number">1</span>)=<span class="number">4</span>) 최대 이익은 <span class="number">4</span>입니다.</span><br><span class="line">Note : transaction은 중복해서 이루어지지 않는다는 점에 유의해야 합니다(병행 불가).</span><br></pre></td></tr></table></figure><h3 id="Test-Case3"><a href="#Test-Case3" class="headerlink" title="Test Case3"></a><strong>Test Case3</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure><h2 id="🔍-풀이"><a href="#🔍-풀이" class="headerlink" title="🔍 풀이"></a><strong>🔍 풀이</strong></h2><h3 id="해설"><a href="#해설" class="headerlink" title="해설"></a><strong>해설</strong></h3><p>첫번째 테스트 케이스를 예시로 설명하겠습니다.</p><h4 id="첫번째-transaction"><a href="#첫번째-transaction" class="headerlink" title="첫번째 transaction"></a><strong>첫번째 transaction</strong></h4><p>첫번째 transaction은 왼쪽에서 오른쪽으로 이익을 계산합니다. S_min은 stock[:i] 의 최소값이고, 최대 이익은 stock[i] - S_min 의 최대값이 저장됩니다.</p><table><thead><tr><th align="center">stock</th><th align="center">3</th><th align="center">3</th><th align="center">5</th><th align="center">0</th><th align="center">0</th><th align="center">3</th><th align="center">1</th><th align="center">4</th></tr></thead><tbody><tr><td align="center"><strong>최대 이익</strong>(tmp1)</td><td align="center">0</td><td align="center">0</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center"><strong>S_min</strong></td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table><h4 id="두번째-transaction"><a href="#두번째-transaction" class="headerlink" title="두번째 transaction"></a><strong>두번째 transaction</strong></h4><p>두번째 transaction은 오른쪽에서 왼쪽으로 이익을 계산합니다. S_max은 stock[n-i:n] 의 최대값이고, 최대 이익은 S_max - stock[i]의 최대값이 저장됩니다. </p><table><thead><tr><th align="center">stock</th><th align="center">3</th><th align="center">3</th><th align="center">5</th><th align="center">0</th><th align="center">0</th><th align="center">3</th><th align="center">1</th><th align="center">4</th></tr></thead><tbody><tr><td align="center"><strong>최대 이익</strong>(tmp2)</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">3</td><td align="center">3</td><td align="center">0</td></tr><tr><td align="center"><strong>S_max</strong></td><td align="center">5</td><td align="center">5</td><td align="center">5</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">4</td></tr></tbody></table><h4 id="최대-이익-계산"><a href="#최대-이익-계산" class="headerlink" title="최대 이익 계산"></a><strong>최대 이익 계산</strong></h4><p>이때 tmp1[i] + tmp2[i]은 가능한 이익의 경우의 수입니다.</p><table><thead><tr><th align="center">이익(tmp1[i]+tmp2[i])</th><th align="center">4</th><th align="center">4</th><th align="center">6</th><th align="center">6</th><th align="center">6</th><th align="center">6</th><th align="center">6</th><th align="center">4</th></tr></thead><tbody><tr><td align="center"><strong>최대 이익</strong>(tmp1)</td><td align="center">0</td><td align="center">0</td><td align="center">2</td><td align="center">2</td><td align="center">2</td><td align="center">3</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center"><strong>최대 이익</strong>(tmp2)</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">4</td><td align="center">3</td><td align="center">3</td><td align="center">0</td></tr></tbody></table><p>따라서 결과값은 tmp1[i] + tmp2[i]의 최대값으로 계산합니다.</p><h3 id="코드"><a href="#코드" class="headerlink" title="코드"></a><strong>코드</strong></h3><p>사용 언어는 <code>python3</code>입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># [LeetCode] week-3-august-16th</span></span><br><span class="line"><span class="comment"># @Jihyun22</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># input -&gt; 괄호 제거, &#x27;,&#x27;기준으로 int값 분할하여 stock이름의 list 생성</span></span><br><span class="line">stock = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().strip(<span class="string">&#x27;[]&#x27;</span>).split(<span class="string">&#x27;,&#x27;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">stock</span>):</span></span><br><span class="line">    day = <span class="built_in">len</span>(stock)</span><br><span class="line">    <span class="comment"># 입력값이 2개 미만이면 0 return</span></span><br><span class="line">    <span class="keyword">if</span> day &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 양 끝값에서 중앙으로 탐색</span></span><br><span class="line">    left, right = stock[<span class="number">0</span>], stock[day-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 최대 트렌젝션은 2번 일어나므로 각각 이익 저장할 배열 선언</span></span><br><span class="line">    tmp1, tmp2 = [<span class="number">0</span>]*day, [<span class="number">0</span>]*day</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, day):</span><br><span class="line">        <span class="comment"># 왼쪽 -&gt; 오른쪽 순으로 S_min 연산</span></span><br><span class="line">        tmp1[i] = <span class="built_in">max</span>(tmp1[i-<span class="number">1</span>], stock[i]-left)</span><br><span class="line">        left = <span class="built_in">min</span>(left, stock[i])</span><br><span class="line">        <span class="comment"># 오른쪽 -&gt; 왼쪽 순으로 S_max 연산</span></span><br><span class="line">        j = day-<span class="number">1</span>-i</span><br><span class="line">        tmp2[j] = <span class="built_in">max</span>(tmp2[j+<span class="number">1</span>], right-stock[j])</span><br><span class="line">        right = <span class="built_in">max</span>(right, stock[j])</span><br><span class="line">        <span class="comment"># 이익은 음수가 될 수 없으므로 초기값은 0</span></span><br><span class="line">        result = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 각각의 tmp에서 i번째 수의 합은 이익의 경우의 수</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(day):</span><br><span class="line">        <span class="comment"># 이익의 최대값 연산</span></span><br><span class="line">        result = <span class="built_in">max</span>(result, tmp1[i]+tmp2[i])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maxProfit(stock))</span><br></pre></td></tr></table></figure><h2 id="📝-Submit"><a href="#📝-Submit" class="headerlink" title="📝 Submit"></a><strong>📝 Submit</strong></h2><p>LeetCode 제출 코드입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, stock: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        day = <span class="built_in">len</span>(stock)</span><br><span class="line">        tmp1 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(day)]</span><br><span class="line">        tmp2 = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(day)]</span><br><span class="line">        cache = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(day)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(day)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, day):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, day):</span><br><span class="line">                cache[i][j] = stock[j]-stock[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(day-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            tmp1[i] = <span class="built_in">max</span>(cache[i][<span class="number">0</span>:i+<span class="number">2</span>])</span><br><span class="line">            tmp2[i] = <span class="built_in">max</span>(cache[<span class="number">0</span>:i+<span class="number">2</span>][i])</span><br><span class="line"></span><br><span class="line">        tmp1.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">sum</span>(tmp1[<span class="number">0</span>:<span class="number">2</span>]), <span class="built_in">max</span>(tmp2))</span><br></pre></td></tr></table></figure><p><em>LeetCode는 사용 언어 별 default 형식으로 작성해야 평가가 진행됩니다.</em> </p><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Algorithm/">Algorithm 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/categories/Algorithm/leetcode/">Leetcode 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/">Algorithm</category>
      
      <category domain="https://jihyun22.github.io/categories/Algorithm/leetcode/">leetcode</category>
      
      
      <category domain="https://jihyun22.github.io/tags/leetcode/">leetcode</category>
      
      <category domain="https://jihyun22.github.io/tags/algorithm/">algorithm</category>
      
      <category domain="https://jihyun22.github.io/tags/python/">python</category>
      
      
      <comments>https://jihyun22.github.io/2020/08/16/leetcode-08-16/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[데이콘 온도추정 대회] 모델 적용하기</title>
      <link>https://jihyun22.github.io/2020/03/15/temperature-forecast-02/</link>
      <guid>https://jihyun22.github.io/2020/03/15/temperature-forecast-02/</guid>
      <pubDate>Sun, 15 Mar 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;데이콘에서 20년 3-4월 진행된 &lt;a href=&quot;https://dacon.io/competitions/official/235584/overview/&quot;&gt;AI프렌즈 시즌1 온도 추정 경진대회&lt;/a&gt;에 대해 리뷰하며, 이전에 다룬 내용을 바탕으로 기본 아이디어와 LSTM 모델 적용 결과를 알아보겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>데이콘에서 20년 3-4월 진행된 <a href="https://dacon.io/competitions/official/235584/overview/">AI프렌즈 시즌1 온도 추정 경진대회</a>에 대해 리뷰하며, 이전에 다룬 내용을 바탕으로 기본 아이디어와 LSTM 모델 적용 결과를 알아보겠습니다.</p><span id="more"></span><hr><p>1편과 이어지는 자료입니다. 자세한 내용은 아래를 참고해주세요.</p><ul><li>[데이콘 온도추정 대회] 데이터셋 구조 살펴보기</li></ul><h2 id="2-모델-데모"><a href="#2-모델-데모" class="headerlink" title="2. 모델 데모"></a>2. 모델 데모</h2><h3 id="2-1-기본-아이디어"><a href="#2-1-기본-아이디어" class="headerlink" title="2.1. 기본 아이디어"></a>2.1. 기본 아이디어</h3><p>앞에서 살펴본 데이터셋의 특징은 크게 두가지입니다.</p><ul><li>데이터의 크기가 <strong>상당히</strong> 작다.<ul><li>기상청 데이터의 피처는 40개, 온도 센서 측정값까지 더하면 60개 남짓입니다.</li></ul></li><li>일자 별 <strong>누락된</strong> 데이터가 있다.<ul><li><code>test</code> 의 80일치 기상청 데이터를 예측해야 하는데, <code>Y18</code> 은 3일치의 데이터만 주어져 있습니다.</li></ul></li></ul><p>따라서 <strong>적은 데이터셋으로 높은 정확도의 정보를 어떻게 이끌어 낼 것인가</strong>가 중요한 요점입니다. 이러한 특징을 바탕으로 기본 아이디어를 설계해보겠습니다.</p><p>위 표에서 누락된 데이터가 있는 영역을 나누어 (가) ~ (자) 총 9개의 섹션으로 구분했습니다. </p><table><thead><tr><th align="center">구분</th><th align="left">train - 30일</th><th align="left">train - 3일</th><th align="left">test - 80일</th></tr></thead><tbody><tr><td align="center"><code>Y00</code> ~ <code>Y17</code>  (18개)</td><td align="left">(가) <em>공개</em></td><td align="left">(라) <span style="color:red">비공개</span></td><td align="left">(사) <span style="color:red">비공개</span></td></tr><tr><td align="center"><code>Y18</code></td><td align="left">(나) <span style="color:red">비공개</span></td><td align="left">(마) <em>공개</em></td><td align="left">(아) <span style="color:blue">목표값</span></td></tr><tr><td align="center"><code>X00</code> ~ <code>X39</code>  (40개)</td><td align="left">(다) <em>공개</em></td><td align="left">(바) <em>공개</em></td><td align="left">(자) <em>공개</em></td></tr></tbody></table><ol><li><strong>X (다) + y (가) 모델1 학습</strong><ul><li>30일 간의 <code>X00</code> ~ <code>X39</code> 의 기상청 데이터 값으로 30일 간의 <code>Y00</code> ~ <code>Y17</code>  의 온도 센서 측정 값을 학습시켜 모델1을 만듭니다.</li></ul></li><li><strong>모델1 : X (바) →  y (라) 예측</strong><ul><li>3일 간의 <code>X00</code> ~ <code>X39</code> 의 기상청 데이터 값으로 3일 간의 <code>Y00</code> ~ <code>Y17</code>  의 온도 센서 측정 값을 예측할 수 있습니다.</li></ul></li><li><strong>X (바+라) + y (마) 모델2 학습</strong><ul><li>3일 간의 <code>X00</code> ~ <code>X39</code> 의 기상청 데이터 값과 3일 간의 <code>Y00</code> ~ <code>Y17</code>  의 온도 센서 측정 값으로 <code>Y18</code> 의 온도 센서 측정 값을 학습시켜 모델2을 만듭니다.</li></ul></li><li><strong>모델1 : X (자) →  y (사) 예측</strong><ul><li>80일 간의 <code>X00</code> ~ <code>X39</code> 의 기상청 데이터 값으로 80일 간의 <code>Y00</code> ~ <code>Y17</code>  의 온도 센서 측정 값을 예측할 수 있습니다.</li></ul></li><li><strong>모델2 : X (자+사) →  y (아) 예측</strong><ul><li>80일 간의 <code>X00</code> ~ <code>X39</code> 의 기상청 데이터 값과 80일 간의 <code>Y00</code> ~ <code>Y17</code>  의 온도 센서 측정 값으로  80일 간의 <code>Y18</code>  의 온도 센서 측정 값을 예측할 수 있습니다. </li></ul></li></ol><p>작은 데이터 크기를 보정하기 위해 모델 2는 기상청 데이터 뿐 아니라 <code>Y00</code> ~ <code>Y17</code>  의 온도 센서 측정 값을 포함시켜 학습하고자 합니다. 따라서 목표값인 (아) 예측 성능은 <strong>(사)의 예측 정확도에 좌우될 수 있다</strong>는 점에 유의해야 합니다.</p><hr><h3 id="2-2-모델-선정"><a href="#2-2-모델-선정" class="headerlink" title="2.2. 모델 선정"></a>2.2. 모델 선정</h3><p>기본 아이디어를 바탕으로 모델 데모를 작성하기 위해 머신러닝 모델을 선정하겠습니다.</p><p>예측 값이 2차원인 모델 1은 3차원 분석이 가능한 <code>LSTM</code>이 적절하다고 판단됩니다.</p><p>모델2는 예측 값이 <code>Y18</code> 하나로 1차원이기에 다양한 모델이 선호될 수 있습니다. 우선 데모를 위해 간단하게 모델 1과 모델 2 모두 <code>LSTM</code> 를 적용해보겠습니다.</p><hr><h3 id="2-3-모델-학습"><a href="#2-3-모델-학습" class="headerlink" title="2.3 모델 학습"></a>2.3 모델 학습</h3><p> 전체적인 코드는 링크를 참조해주세요. 로컬에서 <code>Jupyter</code> 로 작업하였으며 workplace 내 <code>train.csv</code>, <code>test.csv</code> 를 위치시켰습니다.</p><h4 id="2-3-1-데이터-로드"><a href="#2-3-1-데이터-로드" class="headerlink" title="2.3.1 데이터 로드"></a>2.3.1 데이터 로드</h4><p>우선 데이터를 로드하겠습니다. 모델1을 만들기 위한 데이터 구성입니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 트레인셋</span></span><br><span class="line">train = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>, index_col=<span class="literal">False</span>)</span><br><span class="line">X_train = train.loc[:,<span class="string">&#x27;X00&#x27;</span>:<span class="string">&#x27;X39&#x27;</span>]</span><br><span class="line">y_train = train.loc[:,<span class="string">&#x27;Y00&#x27;</span>:<span class="string">&#x27;Y17&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 테스트 셋</span></span><br><span class="line">test = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>, index_col=<span class="literal">False</span>)</span><br><span class="line">test=test.drop([<span class="string">&#x27;id&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>기상청 데이터값을 <code>X_train</code> 으로,   <code>Y00</code> ~ <code>Y17</code>  온도 센서 측정 값을 <code>y_train</code> 으로 로드했습니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nan 값 제거</span></span><br><span class="line">y = y_train.dropna()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 트레인 셋 범주 조정</span></span><br><span class="line">X = X_train.loc[:y.shape[<span class="number">0</span>]-<span class="number">1</span>,:]</span><br></pre></td></tr></table></figure><p>이후, <code>y_train</code>의 결측치를 제거하여 30일 간의  <code>Y00</code> ~ <code>Y17</code>  온도 센서 측정 값을 <code>y</code> 로 저장했습니다. 모델 구축을 위해 33일 간의 기상청 데이터로 구성된  <code>X_train</code> 도 <code>y</code> 와 <strong>같은 수의 row</strong>를 가진 <code>X</code>로  조정합니다.</p><p>이제 데이터 프레임 <code>X</code> 와 <code>y</code> 는 각각 <strong>30일 간</strong>의 기상청 데이터와 온도 센서 측정 값으로 구성되어 있습니다. </p><ul><li><code>X.shape</code>  : <em>(4320, 40)</em></li><li><code>y.shape</code>  : <em>(4320, 18)</em></li></ul><h4 id="2-3-2-모델-1-학습"><a href="#2-3-2-모델-1-학습" class="headerlink" title="2.3.2 모델 1 학습"></a>2.3.2 모델 1 학습</h4><p>다음은 <code>LSTM</code>모델을 세팅하겠습니다. 모든 파라미터는 <code>default</code> 값입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">import</span> keras.backend <span class="keyword">as</span> K</span><br><span class="line"><span class="keyword">from</span> keras.callbacks <span class="keyword">import</span> EarlyStopping</span><br><span class="line"></span><br><span class="line">K.clear_session()</span><br><span class="line">model_1 = Sequential() <span class="comment"># Sequeatial Model</span></span><br><span class="line">model_1.add(LSTM(<span class="number">20</span>, input_shape=(X.shape[<span class="number">1</span>], <span class="number">1</span>))) <span class="comment"># 트레인값</span></span><br><span class="line">model_1.add(Dense(y.shape[<span class="number">1</span>])) <span class="comment"># 출력값</span></span><br><span class="line">model_1.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model_1.summary()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/tf/6.JPG" alt="model_1.summary 결과값"></p><p><code>LSTM</code> 모델에 사용되는 학습 데이터와 출력값의 크기를 세팅하였습니다. </p><p>이제 세팅한 학습 데이터의 크기에 맞게 <code>X</code> 를 조정하겠습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = X.values</span><br><span class="line">X = X.reshape(X.shape[0], X.shape[1], 1)</span><br></pre></td></tr></table></figure><p><code>pandas</code>   <code>dataframe</code> 을 <code>LSTM</code>의 학습 데이터로 사용하기 위해서는 <code>.values</code> 로  <code>dataframe</code> 을 풀어준 후, <code>.reshape</code> 메소드로 (x, y, z) 값을 설정하면 됩니다.  </p><p>모델 학습을 진행하겠습니다. 일정 이상 loss값에 도달하면 <code>early stop</code> 되며 다른 파라미터는 기본값 세팅으로 사용했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">early_stop = EarlyStopping(monitor=<span class="string">&#x27;loss&#x27;</span>, patience=<span class="number">1</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model_1.fit(X, y, epochs=<span class="number">10000</span>,</span><br><span class="line">          batch_size=<span class="number">30</span>, verbose=<span class="number">1</span>, callbacks=[early_stop])</span><br></pre></td></tr></table></figure><p>최종 loss값 <tt>5.869</tt>으로 학습을 마무리했습니다.</p><p>모델1은 기본 아이디어에 따라 이후 사용됩니다. 재사용의 편의를 위해 모델을 저장하고 적용 함수를 만들었습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#모델 저장</span></span><br><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line">joblib.dump(model_1, <span class="string">&#x27;model_1.pkl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모델 적용 함수</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_fit_1</span>(<span class="params">data, model_name, file_name</span>):</span></span><br><span class="line">    model = joblib.load(<span class="built_in">str</span>(model_name)) </span><br><span class="line">    data_r = data.values.reshape(data.shape[<span class="number">0</span>],data.shape[<span class="number">1</span>],<span class="number">1</span> )</span><br><span class="line">    pred_out=model.predict(data_r)</span><br><span class="line">    df = pd.DataFrame(pred_out)</span><br><span class="line">    df.to_csv(<span class="built_in">str</span>(file_name), index = <span class="literal">False</span>, header = <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><p>이 모델로 지난 3일간의 <code>y</code> 값 (라)을 연산했습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#지난 3일간의 데이터셋</span></span><br><span class="line">X_test = X_train.loc[y.shape[<span class="number">0</span>]:,:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#지난3일간의 y값 연산</span></span><br><span class="line">pred_out = model_fit_1(X_test, <span class="string">&#x27;model_1.pkl&#x27;</span>, <span class="string">&#x27;pred_out_1.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-3-3-모델-2-학습"><a href="#2-3-3-모델-2-학습" class="headerlink" title="2.3.3. 모델 2 학습"></a>2.3.3. 모델 2 학습</h4><p>이제  <em>X (바+라) + y (마) 모델2 학습</em> 단계입니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X=pd.concat([X_test.reset_index(drop=<span class="literal">True</span>), pred_out.reset_index(drop=<span class="literal">True</span>)], axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">y = train[<span class="string">&#x27;Y18&#x27;</span>]</span><br><span class="line">y = y.dropna()</span><br></pre></td></tr></table></figure><p>우선 3일간의 <code>X</code> 값과 모델 1에서 연산한 (라)값을 합하여 <code>X</code> 를 구성하였습니다. <code>y</code> 는 3일 간의 <code>Y18</code> 온도 센서 측정 값입니다.</p><p><code>LSTM</code> 모델을 세팅합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">K.clear_session()</span><br><span class="line">model_2 = Sequential() <span class="comment"># Sequeatial Model</span></span><br><span class="line">model_2.add(LSTM(<span class="number">20</span>, input_shape=(X.shape[<span class="number">1</span>], <span class="number">1</span>)))</span><br><span class="line">model_2.add(Dense(<span class="number">1</span>)) <span class="comment"># output = 1</span></span><br><span class="line">model_2.<span class="built_in">compile</span>(loss=<span class="string">&#x27;mean_squared_error&#x27;</span>, optimizer=<span class="string">&#x27;adam&#x27;</span>)</span><br><span class="line"></span><br><span class="line">model_2.summary()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/tf/7.JPG" alt="model_2.summary 결과값"></p><p>모델 1과 동일하나, <code>y18</code> 의 크기를 고려하여  <code>output</code> 데이터의 크기를 1로 조정했습니다.</p><p>모델 1과 동일하게 세팅한 학습 데이터의 크기에 맞게 <code>X</code> 를 조정하겠습니다.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = X.values</span><br><span class="line">X = X.reshape(X.shape[0], 58, 1)</span><br></pre></td></tr></table></figure><p>이때,  <code>X</code> 의 y값은 40개의 기상청 데이터와 18개의 온도 측정 센서를 더한 58로 설정합니다. </p><p>모델 학습을 진행하겠습니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">early_stop = EarlyStopping(monitor=<span class="string">&#x27;loss&#x27;</span>, patience=<span class="number">1</span>, verbose=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">model_2.fit(X, y, epochs=<span class="number">10000</span>,</span><br><span class="line">          batch_size=<span class="number">30</span>, verbose=<span class="number">1</span>, callbacks=[early_stop])</span><br></pre></td></tr></table></figure><p>최종 loss값 <tt>6.6453</tt>으로 학습을 마무리했습니다.</p><p>모델2 역시 기본 아이디어에 따라 이후 사용됩니다. 재사용의 편의를 위해 모델을 저장하고 적용 함수를 만들었습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">joblib.dump(model_2, <span class="string">&#x27;model_2.pkl&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 모델2 적용 함수</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">model_fit_2</span>(<span class="params">data1, data2, model_name, file_name</span>):</span></span><br><span class="line">    data=pd.concat([data1.reset_index(drop=<span class="literal">True</span>), data2.reset_index(drop=<span class="literal">True</span>)], axis=<span class="number">1</span>)</span><br><span class="line">    model = joblib.load(<span class="built_in">str</span>(model_name))</span><br><span class="line">    data_r = data.values.reshape(data.shape[<span class="number">0</span>],data.shape[<span class="number">1</span>],<span class="number">1</span> )</span><br><span class="line">    pred_out=model.predict(data_r)</span><br><span class="line">    df = pd.DataFrame(&#123;<span class="string">&#x27;id&#x27;</span>:<span class="built_in">range</span>(<span class="number">144</span>*<span class="number">33</span>, <span class="number">144</span>*<span class="number">113</span>),</span><br><span class="line">              <span class="string">&#x27;Y18&#x27;</span>:pred_out.reshape(<span class="number">1</span>,-<span class="number">1</span>)[<span class="number">0</span>]&#125;)</span><br><span class="line">    df.to_csv(file_name, index = <span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">return</span> df</span><br></pre></td></tr></table></figure><hr><h2 id="3-평가"><a href="#3-평가" class="headerlink" title="3. 평가"></a>3. 평가</h2><p>본 대회의 평가지표는 MSE입니다. MSE관련 내용은 다른 포스트에서 소개하겠습니다.</p><p>만든 모델을 평가하겠습니다. 80일 간의 기상청 데이터 값인 <code>test</code> 값으로 제출 파일을 만들었습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 모델1 : X (자) →  y (사) 예측</span></span><br><span class="line">pred_out_1 = model_fit_1(test, <span class="string">&#x27;model_1.pkl&#x27;</span>, <span class="string">&#x27;pred_out_1.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># 모델2 : X (자+사) →  y (아) 예측</span></span><br><span class="line">pred_out_fin = model_fit_2(test, pred_out_1, <span class="string">&#x27;model_2.pkl&#x27;</span>, <span class="string">&#x27;pred_out_fin.csv&#x27;</span>)</span><br></pre></td></tr></table></figure><p>제출 결과, 8.9381423723점으로 약 9점에 가까운 점수를 받았습니다. </p><p>데이터 전처리 없이 기본 LSTM 모델로 학습을 진행한 데모이기에, 9점이 좋은 모델의 지표가 될 수 있을거라 생각됩니다.</p><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/categories/Machine-Learning/Dacon/">Dacon 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/tags/temperature-forecast/">Dacon 온도추정 대회 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning</category>
      
      <category domain="https://jihyun22.github.io/categories/Machine-Learning/Dacon/">Dacon</category>
      
      
      <category domain="https://jihyun22.github.io/tags/Dacon/">Dacon</category>
      
      <category domain="https://jihyun22.github.io/tags/temperature-forecast/">temperature-forecast</category>
      
      
      <comments>https://jihyun22.github.io/2020/03/15/temperature-forecast-02/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>시계열 데이터를 다뤄보자 - 비트코인 시세 예측하기</title>
      <link>https://jihyun22.github.io/2020/03/15/time-series/</link>
      <guid>https://jihyun22.github.io/2020/03/15/time-series/</guid>
      <pubDate>Sun, 15 Mar 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;시간 축과 데이터로 이루어진 시계열 데이터, 그 중 불규칙한 시계열 데이터를 살펴보고 ARIMA 모델로 트렌드 예측을 진행합니다.&lt;/p&gt;
&lt;p&gt;비트코인 시세 데이터를 활용하여 시간 축과 데이터로 이루어진 시계열 데이터, 그 중 불규칙한 시계열 데이터를 살펴보고 ARIMA 모델로 트렌드 예측을 진행합니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>시간 축과 데이터로 이루어진 시계열 데이터, 그 중 불규칙한 시계열 데이터를 살펴보고 ARIMA 모델로 트렌드 예측을 진행합니다.</p><p>비트코인 시세 데이터를 활용하여 시간 축과 데이터로 이루어진 시계열 데이터, 그 중 불규칙한 시계열 데이터를 살펴보고 ARIMA 모델로 트렌드 예측을 진행합니다.</p><span id="more"></span><h2 id="0-시계열-데이터"><a href="#0-시계열-데이터" class="headerlink" title="0. 시계열 데이터"></a>0. 시계열 데이터</h2><p>시계열 데이터는 연속적인 시간에 따라 다르게 측정되는 데이터입니다.</p><p>즉, 관측치가 시간적 순서를 가진 데이터로 변수간의 상관성이 존재하는 데이터를 의미합니다.</p><ol><li>규칙적 시계열 데이터를 분석 <em>(예. 심장박동 데이터)</em></li><li>불규칙적 시계열 데이터를 분석 <em>(예. 비트코인 시세 예측)</em></li></ol><p>시계열 데이터는 과거의 데이터를 통해서 현재의 동향이나 미래를 예측하는데 사용됩니다. 과거의 특정 구간대의 데이터를 통해 미래를 예측할 수 있다는 것입니다.</p><p>이번 포스팅에서는 3년간 비트코인 시세를 바탕으로 일주일 간의 비트코인 시세를 예측해보려고 합니다. blockchain에서 제공하는 데이터를 재가공하여 사용하였으며, 원본 데이터셋은 <a href="https://www.blockchain.com/ko/charts/market-price">링크</a>에서 다운로드 받을 수 있습니다.</p><p><img src="https://jihyun22.github.io/img/bc/1_1.png" alt="비트코인 데이터 다운로드 화면"></p><p><em>간혹 확장자가 없는 파일로 다운로드되는데, 확장자 .csv를 붙여주기만 하면 사용할 수 있습니다.</em></p><p>본 포스팅에서 사용하는 학습 데이터는 3년간 시세 데이터(<a href="https://github.com/Jihyun22/data_analysis/blob/master/train.csv">train.csv</a>) , 테스트 데이터는 7일간 시세 데이터(<a href="https://github.com/Jihyun22/data_analysis/blob/master/test.csv">test.csv</a>)를 사용하였습니다. 데이터셋 환경 구축이 완료되었다면 데이터를 로드해보겠습니다.</p><hr><h2 id="1-데이터-로드"><a href="#1-데이터-로드" class="headerlink" title="1. 데이터 로드"></a>1. 데이터 로드</h2><p>train데이터를 살펴보면 결측값 없이 1091개의 행과 2개의 칼럼으로 구성되어 있습니다. 2개의 칼럼은 각각 time과 price로 시계열 데이터 구조입니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3년치 데이터 로드</span></span><br><span class="line">train_path = <span class="string">&#x27;train.csv&#x27;</span></span><br><span class="line">train = pd.read_csv(train_path, skiprows = [<span class="number">0</span>], names=[<span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;price&#x27;</span>] )</span><br><span class="line">train.info()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;class &#x27;pandas.core.frame.DataFrame&#x27;&gt;</span><br><span class="line">RangeIndex: 1091 entries, 0 to 1090</span><br><span class="line">Data columns (total 2 columns):</span><br><span class="line">time     1091 non-null object</span><br><span class="line">price    1091 non-null float64</span><br><span class="line">dtypes: float64(1), object(1)</span><br><span class="line">memory usage: 17.2+ KB</span><br></pre></td></tr></table></figure><p>이제 시계열 정보를 <code>to_datetime</code>메소드를 사용하여 DataFrame의 index로 설정합니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># to_datetime 메소드를 통해 day 피처를 시계열 피처 처리</span></span><br><span class="line">train[<span class="string">&#x27;time&#x27;</span>] = pd.to_datetime(train[<span class="string">&#x27;time&#x27;</span>])</span><br><span class="line"><span class="comment"># 프레임 인덱스 설정</span></span><br><span class="line">train.index = train[<span class="string">&#x27;time&#x27;</span>]</span><br><span class="line">train.set_index(<span class="string">&#x27;time&#x27;</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><code>Pandas</code>에서 시계열 자료를 생성하기 위해서는 <code>DatetimeIndex</code> 자료형으로 데이터 구조를 조작해야 합니다. <code>to_datetime</code> 메소드를 사용하면 날짜 또는 시간을 나타내는 문자열을 자동으로 <code>datetime</code> 자료형으로 바꾼 후 인덱스를 생성할 수 있습니다. </p><p>시계열 피처를 처리한 후 시각화 한 결과입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 시각화</span></span><br><span class="line">train.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/bc/1_2.png" alt="시각화 결과"></p><hr><h2 id="2-ARIMA-모델"><a href="#2-ARIMA-모델" class="headerlink" title="2. ARIMA 모델"></a>2. ARIMA 모델</h2><h3 id="2-1-모델-소개"><a href="#2-1-모델-소개" class="headerlink" title="2.1. 모델 소개"></a>2.1. 모델 소개</h3><p><code>ARIMA</code> 분석 방법은 크게 두가지 개념을 포함하고 있습니다.</p><ul><li><code>AR</code> 모델 : 현재의 상태는 이전의 상태를 참고해서 계산된다는 전제 하자기 자신의 과거를 정보로 사용하는 개념</li><li><code>MA</code> 모델 : 이전 항에서의 오차를 이용하여 현재 항의 상태를 추론하겠다는 방법</li></ul><p>이 둘을 합친 모델을 <code>ARMA</code> 모델이라고 하며, 이에 추세 변동의 경향성까지 반영한 모델이 <code>ARIMA</code> 모델입니다.</p><p><code>ARIMA</code> 모델의 특징은 선형관계(Correlation)뿐 아니라 추세관계(Cointegtation)까지 고려한 모델이라는 점입니다. </p><p>선형관계는 현재의 관계를 의미하고, 추세관계는 과거 현상에서 유추할 수 있는 미래의 수치 간 관계를 의미합니다. 변수 X와 Y간 관계로 간단하게 설명하면 아래의 표와 같습니다.</p><table><thead><tr><th>구분</th><th align="center">Cointegtation &gt; 0</th><th align="center">Cointegtation &lt; 0</th></tr></thead><tbody><tr><td>Correlation &gt; 0</td><td align="center">X가 양의 값이고 증가하는 추세일 때, Y는 양의 값이고 증가하는 추세</td><td align="center">X가 양의 값이고 증가하는 추세일 때, Y는 양의 값이고 감소하는 추세</td></tr><tr><td>Correlation &lt; 0</td><td align="center">X가 양의 값이고 증가하는 추세일 때, Y는 음의 값이고 증가하는 추세</td><td align="center">X가 양의 값이고 증가하는 추세일 때, Y는 음의 값이고 감소하는 추세</td></tr></tbody></table><h3 id="2-3-파라미터-조정"><a href="#2-3-파라미터-조정" class="headerlink" title="2.3 파라미터 조정"></a>2.3 파라미터 조정</h3><p>파이썬에서는 <code>statsmodel</code> 모듈로 <code>ARIMA</code> 분석을 할 수 있습니다. <code>ARIMA</code> 모델을 구성할 때 클래스에 order = (p, d, q) 파라미터 값을 입력해주어야 하는데 적절한 값을 탐색해보겠습니다. 이때 p는 AR이 몇 번째 과거까지 바라보는지에 대한 파라미터, d는 차분에 대한 파라미터, q는 MA가 몇번째 과거까지 바라보는지에 대한 파라미터를 의미합니다. </p><p>(p, d, q)의 최적 조합을 찾기 위해 <code>plot_acf</code>, <code>plot_pacf </code>결과를 살펴보겠습니다.</p><ul><li>ACF :  관측치들 사이 관련성을 측정</li><li>PACF : K 이외의 모든 다른 시점 관측치의 영향력을 배제하고 일정 시점의 주 관측치의 관련성을 측정</li></ul><p>시계열 데이터가 AR의 측성을 띄는 경우, ACF는 천천히 감소하고 PACF는 처음 시차를 제외하고 급격히 감소합니다. MA의 특성을 띄는 경우 AR과 반대로 ACF 값은 급격히 감소, PACF는 천천히 감소하는 경향을 보입니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ARIMA 의 order 파라미터 p,d,q의 최적 조합 찾기</span></span><br><span class="line"><span class="keyword">from</span> statsmodels.graphics.tsaplots <span class="keyword">import</span> plot_acf, plot_pacf</span><br><span class="line"></span><br><span class="line">plot_acf(train)</span><br><span class="line">plot_pacf(train)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/bc/1_3.png" alt="plot_acf 결과"></p><p><img src="https://jihyun22.github.io/img/bc/1_4.png" alt="plot_pacf 결과"></p><p>ACF 결과를 살펴보면, 자기상관은 항상 양의 값을 가지고 있습니다. p의 값은 크게 조절할 필요가 없다고 판단됩니다. PACF 결과는 처음 시차를 제외하고 급격히 감소합니다. 종합적으로 고려하면 p=0, q=1로 파라미터를 조정하는 것이 적절하다고 판단됩니다.</p><p>참고로, p, d, q의 파라미터는 일반적인 가이드라인이 존재합니다. 보통 p와 q의 합이 2미만이거나, p와 q의 곱이 0을 포합한 짝수가 좋은 조합이라고 알려져 있습니다.</p><p>다음은 차분 차수를 계산하기 위해, 우선 1차 차분 후 다시 acf, pacf 를 수행했습니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 적절 차분 차수 d 계산 </span></span><br><span class="line">tmp=train.diff(periods=<span class="number">1</span>).iloc[<span class="number">1</span>:]</span><br><span class="line">tmp.plot()</span><br><span class="line">plot_acf(tmp)</span><br><span class="line">plot_pacf(tmp)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/bc/1_5.png" alt="1차 차분 후 tmp plot 결과"></p><p><img src="https://jihyun22.github.io/img/bc/1_6.png" alt="1차 차분 후 plot_acf 결과"></p><p><img src="https://jihyun22.github.io/img/bc/1_7.png" alt="1차 차분 후 plot_pacf 결과"></p><p>차분이란 현재 상태의 변수에서 바로 전 상태의 변수를 빼주는 것을 의미하며, 시계열 데이터의 불규칙성을 조금이나마 보정해주는 역할을 수행합니다. 또한 ARIMA의 경향성을 반영한 값입니다. 위 결과를 바탕으로 최종 파라미터는 (0,2,1)로 결정하였습니다.</p><h3 id="2-3-모델학습"><a href="#2-3-모델학습" class="headerlink" title="2.3. 모델학습"></a>2.3. 모델학습</h3><p><code>ARIMA</code> 모델을 활용하여 모델 학습을 수행하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.arima_model <span class="keyword">import</span> ARIMA</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line">model = ARIMA(train.price.values, order=(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>)) <span class="comment">#파라미터 설정</span></span><br><span class="line">model_fit = model.fit(trend=<span class="string">&#x27;c&#x27;</span>, full_output=<span class="literal">True</span>, disp=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(model_fit.summary())</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ARIMA Model Results                              </span><br><span class="line">==============================================================================</span><br><span class="line">Dep. Variable:                   D2.y   No. Observations:                 1089</span><br><span class="line">Model:                 ARIMA(0, 2, 1)   Log Likelihood               -8038.507</span><br><span class="line">Method:                       css-mle   S.D. of innovations            387.378</span><br><span class="line">Date:                Sat, 25 Apr 2020   AIC                          16083.015</span><br><span class="line">Time:                        20:03:06   BIC                          16097.994</span><br><span class="line">Sample:                             2   HQIC                         16088.684</span><br><span class="line">                                                                           </span><br><span class="line">==============================================================================</span><br><span class="line">              coef    std err          z      P&gt;|z|      [0.025      0.975]</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">const         -0.0285      0.037     -0.763      0.445      -0.102       0.045</span><br><span class="line">ma.L1.D2.y    -1.0000      0.003   -356.421      0.000      -1.005      -0.995</span><br><span class="line">                                 Roots                                    </span><br><span class="line">=============================================================================</span><br><span class="line">               Real          Imaginary           Modulus         Frequency</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">MA.1            1.0000           +0.0000j            1.0000            0.0000</span><br><span class="line">-----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p><code>ARIMA</code> 모델의 t-test 값은 <code>p-value</code>로 상수항을 제외한 모든 계수의 <code>p-value</code>가 0.05이하인 경우 유의미합니다. <code>ma.L1.D2.y</code> 변수값의 <code>p-value</code>는 0.000으로 적정한 파라미터 값을 대입했다고 판단됩니다.</p><p>학습한 모델에 학습 데이터 셋을 넣었을 때 시계열 예측 결과입니다. <code>plot_predict()</code> 메소드로 시각화를 자동으로 수행할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 학습 데이터 예측 결과 -&gt; 양호</span></span><br><span class="line">fig = model_fit.plot_predict()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/bc/1_8.png" alt="학습 데이터 예측 결과"></p><p>다음은 실제와 예측값 사이 오차 변동(잔차)을 살펴보겠습니다. 잔차의 폭이 일정할 경우 바람직한 학습 결과를 기대할 수 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 잔차의 변동 시각화</span></span><br><span class="line">residuals = pd.DataFrame(model_fit.resid)</span><br><span class="line">residuals.plot()</span><br><span class="line"><span class="comment"># 폭이 일정해야 좋음 -&gt; 불규칙한 형태</span></span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/bc/1_9.png" alt="잔차의 변동 시각화"></p><p>하지만 실행 결과에서는 상당히 불안정한 잔차값이 나타납니다. 그래도 모델을 추가 수정하지 않고 평가 단계로 넘어가겠습니다.</p><hr><h2 id="3-평가"><a href="#3-평가" class="headerlink" title="3. 평가"></a>3. 평가</h2><h3 id="3-1-예측-결과"><a href="#3-1-예측-결과" class="headerlink" title="3.1. 예측 결과"></a>3.1. 예측 결과</h3><p>모델을 평가하기 위해서 가장 최근 7일치 데이터를 사용하므로, 학습한 모델에서 7일치의 데이터 연산을 진행합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pred_model = model_fit.forecast(steps=<span class="number">7</span>) <span class="comment">#7일 예측</span></span><br><span class="line">pred=pred_model[<span class="number">0</span>].tolist()</span><br></pre></td></tr></table></figure><p>예측값은 변수 <code>pred</code>에 <code>list</code>형태로 저장했습니다.</p><h3 id="3-2-시각화"><a href="#3-2-시각화" class="headerlink" title="3.2. 시각화"></a>3.2. 시각화</h3><p>실제 데이터를 로드하고 예측결과와 비교하기 위해 시각화합니다. 예측 최고가격과 최저가격을 설정한 후 실제 가격과 예측 가격을 비교하겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(pred, color=<span class="string">&quot;blue&quot;</span>) <span class="comment"># 예측 가격</span></span><br><span class="line">plt.plot(pred_lower, color = <span class="string">&quot;gray&quot;</span>) <span class="comment"># 예측 최저가격</span></span><br><span class="line">plt.plot(pred_upper, color = <span class="string">&quot;pink&quot;</span>) <span class="comment"># 예측 최고가격</span></span><br><span class="line">plt.plot(test, color = <span class="string">&quot;red&quot;</span>) <span class="comment"># 실제가격</span></span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/bc/1_11.png" alt="예측된 최저, 최고 가격 비교"></p><p>예측 가격과 실제 가격의 추이가 비슷한 양상을 띄는 것을 확인할 수 있습니다.</p><p>이번에는 더욱 자세히 비교하기 위해  최저, 최고 가격을 제외하고 예측 가격과 실제 가격만의 그래프를 확인해보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=test.price.values <span class="comment"># 데이터 형식 list로 변경</span></span><br><span class="line">plt.plot(pred, color=<span class="string">&quot;blue&quot;</span>) <span class="comment"># 예측 가격</span></span><br><span class="line">plt.plot(test_y, color = <span class="string">&quot;red&quot;</span>) <span class="comment"># 실제가격</span></span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/bc/1_10.png" alt="예측 가격과 실제 가격 비교"></p><p>세부 결과는 좋지 않았습니다. 예측 가격은 7일동안 낮아질 것으로 나타났으나, 실제 데이터는 등락을 반복하는 경향을 보였습니다. 그러나 최고, 최저 예측 가격의 폭이 약 4000인 것을 고려한다면 600정도(0.15)의 오차는 그렇게 큰 편은 아니라고 판단됩니다.</p><h3 id="3-3-모델평가"><a href="#3-3-모델평가" class="headerlink" title="3.3. 모델평가"></a>3.3. 모델평가</h3><p>rmse를 사용하여 모델을 평가한 결과입니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">rmse = math.sqrt(mean_squared_error(pred, test_y))</span><br><span class="line"><span class="built_in">print</span>(rmse)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">270.8342603398055</span><br></pre></td></tr></table></figure><p>rmse값은 270으로 처음 감소 추세는 예측 성공하였으나 큰 폭으로 감소하는 결과값을 정확하게 예측하기에는 어려웠습니다. </p><hr><h2 id="4-결론"><a href="#4-결론" class="headerlink" title="4. 결론"></a>4. 결론</h2><p>불규칙한 시계열 예측의 경우, 먼 미래를 예측하는 것은 큰 의미가 없습니다. 따라서 앞으로 N일 동안 어느 정도로 상승(하락)할 것인지 대략적인 Trend 예측만을 수행하는 것이 일반적입니다.</p><ul><li><em>참고자료 : 이것이 데이터 분석이다(윤기태 저)</em></li></ul><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning</category>
      
      
      <category domain="https://jihyun22.github.io/tags/time-serise/">time-serise</category>
      
      <category domain="https://jihyun22.github.io/tags/bitcoin/">bitcoin</category>
      
      
      <comments>https://jihyun22.github.io/2020/03/15/time-series/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[데이콘 온도추정 대회] 데이터셋 구조 살펴보기</title>
      <link>https://jihyun22.github.io/2020/03/14/temperature-forecast-01/</link>
      <guid>https://jihyun22.github.io/2020/03/14/temperature-forecast-01/</guid>
      <pubDate>Sat, 14 Mar 2020 06:00:00 GMT</pubDate>
      
      <description>&lt;p&gt;데이콘에서 20년 3-4월 진행된 &lt;a href=&quot;https://dacon.io/competitions/official/235584/overview/&quot;&gt;AI프렌즈 시즌1 온도 추정 경진대회&lt;/a&gt;에 대해 리뷰하며, 대회에서 제공하는 데이터셋의 구조와 기본 아이디어에 대해 알아보겠습니다.&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>데이콘에서 20년 3-4월 진행된 <a href="https://dacon.io/competitions/official/235584/overview/">AI프렌즈 시즌1 온도 추정 경진대회</a>에 대해 리뷰하며, 대회에서 제공하는 데이터셋의 구조와 기본 아이디어에 대해 알아보겠습니다.</p><span id="more"></span><hr><h2 id="0-배경"><a href="#0-배경" class="headerlink" title="0. 배경"></a>0. 배경</h2><p>데이콘은 데이터 분석, 또는 ML에 대한 대회를 다루는 케글과 비슷한 국내 플랫폼입니다. 앞으로 데이콘의 지난 대회를 리뷰하며 ML에 대한 기본적인 개념을 다루고자 합니다.</p><p>가장 먼저 살펴볼 대회는 올해 2020년 3월부터 4월 중순까지 진행된 AI프렌즈 시즌1 온도 추정 경진대회입니다. 이 대회는 전<em>국에 걸쳐 시도별 기상 관측소가 있지만, 각 지역 내에서도 대상과 위치에 따라 온도 차이가 나는 점을 개선</em>하고자 기획되었습니다. <em>저가의 센서로 관심 대상의 온도를 단기간 측정하여 기상청의 관측 데이터와 상관관계 모델을 만들고 온도를 추정하여 서비스</em>하는 것이 최종 목표입니다.</p><p>대회에 대한 자세한 정보는 아래의 링크를 참조하세요.</p><ul><li><a href="https://dacon.io/competitions/official/235584/overview/">AI프렌즈 시즌1 온도 추정 경진대회</a></li></ul><hr><h2 id="1-데이터-구성"><a href="#1-데이터-구성" class="headerlink" title="1. 데이터 구성"></a>1. 데이터 구성</h2><h3 id="1-1-데이터-설명"><a href="#1-1-데이터-설명" class="headerlink" title="1.1 데이터 설명"></a>1.1 데이터 설명</h3><p>데이콘에서는 각 대회의 데이터 구성 관련 설명 영상을 제공하고 있습니다. 이번 대회에서 사용하는 데이터셋이 어떻게 구성되어 있는지 자세한 설명은 아래의 영상을 참고하세요.</p><p><a href="https://youtu.be/ukzaKsnKfXw"><img src="https://jihyun22.github.io/img/tf/2.JPG" alt="데이터설명"></a></p><p>본 대회에서 사용하는 데이터셋은 DACON <a href="https://dacon.io/competitions/official/235584/data/">링크</a>에서 다운받을 수 있습니다.</p><hr><h3 id="1-2-train"><a href="#1-2-train" class="headerlink" title="1.2. train"></a>1.2. train</h3><p>train 데이터부터 살펴보겠습니다. <code>train.csv</code> 파일에는 총 33일 간 기상청 데이터와 온도 센서 데이터 값이 저장되어 있습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>, index_col=<span class="literal">False</span>,)</span><br><span class="line">train = train.drop([<span class="string">&#x27;id&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">train.shape</span><br></pre></td></tr></table></figure><blockquote><p>(4752, 59)</p></blockquote><p>우선 기상청 데이터는 강수량, 기온, 기압 등을 포함한 <code>X00</code> ~ <code>X39</code>  총 40개의 피처로 주어집니다. 33일간 누락된 값은 없습니다.</p><p>온도 센서 데이터 값은 <code>Y00</code> ~ <code>Y18</code> 총 19개가 존재합니다. <code>train.shape</code> 의 열 값이 59인 이유는 40개의 기상청 데이터와 19개의 온도 센서 데이터 값으로 구성되어 있기 때문입니다.</p><p>이제 각 피처의 누락값 범위를 확인해보겠습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 데이터 처음 5번째 줄 출력</span></span><br><span class="line">train.head()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/tf/3.JPG" alt="train.head 결과값"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 데이터 끝 5번째 줄 출력</span></span><br><span class="line">train.tail()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/tf/4.JPG" alt="train.tail 결과값"></p><p> <code>Y00</code> ~ <code>Y17</code> 까지의 측정값은 30일간의 측정값만 존재하고, <code>Y18</code> 값은 30일 이후의 3일 간의 데이터만 있습니다. 우리가 최종 예측해야 하는 값은 <code>Y18</code> 값입니다.</p><hr><h3 id="1-3-test"><a href="#1-3-test" class="headerlink" title="1.3. test"></a>1.3. test</h3><p>test데이터를 살펴보겠습니다. <code>train.csv</code>는 <code>train.csv</code> 기간 이후 80일 간의 기상청 데이터가 주어집니다. </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test = pd.read_csv(<span class="string">&#x27;test.csv&#x27;</span>, index_col=<span class="literal">False</span>,)</span><br><span class="line">test = test.drop([<span class="string">&#x27;id&#x27;</span>], axis=<span class="number">1</span>)</span><br><span class="line">test.shape</span><br></pre></td></tr></table></figure><blockquote><p>(11520, 40)</p></blockquote><p>누락값은 없습니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 데이터 처음 5번째 줄 출력</span></span><br><span class="line">test.head()</span><br></pre></td></tr></table></figure><p><img src="https://jihyun22.github.io/img/tf/4.JPG" alt="test.head 결과값"></p><p>표로 정리하면 다음과 같습니다.</p><table><thead><tr><th align="center">구분</th><th align="center">train - 30일</th><th align="center">train - 3일</th><th align="center">test - 80일</th></tr></thead><tbody><tr><td align="center"><code>Y00</code> ~ <code>Y17</code>  (18개)</td><td align="center"><em>공개</em></td><td align="center"><span style="color:red">비공개</span></td><td align="center"><span style="color:red">비공개</span></td></tr><tr><td align="center"><code>Y18</code></td><td align="center"><span style="color:red">비공개</span></td><td align="center"><em>공개</em></td><td align="center"><span style="color:blue">목표값</span></td></tr><tr><td align="center"><code>X00</code> ~ <code>X39</code>  (40개)</td><td align="center"><em>공개</em></td><td align="center"><em>공개</em></td><td align="center"><em>공개</em></td></tr></tbody></table><p>이러한 데이터의 특징을 바탕으로, 다음 포스트에서는 모델 구성을 위한 기본 아이디어를 고민하겠습니다.</p><hr><p><strong>관련 카테고리 포스트 더보기</strong></p><blockquote><p><a href="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/categories/Machine-Learning/Dacon/">Dacon 관련 포스트 더보기</a></p><p><a href="https://jihyun22.github.io/tags/temperature-forecast/">Dacon 온도추정 대회 관련 포스트 더보기</a></p></blockquote>]]></content:encoded>
      
      
      <category domain="https://jihyun22.github.io/categories/Machine-Learning/">Machine-Learning</category>
      
      <category domain="https://jihyun22.github.io/categories/Machine-Learning/Dacon/">Dacon</category>
      
      
      <category domain="https://jihyun22.github.io/tags/Dacon/">Dacon</category>
      
      <category domain="https://jihyun22.github.io/tags/temperature-forecast/">temperature-forecast</category>
      
      
      <comments>https://jihyun22.github.io/2020/03/14/temperature-forecast-01/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
